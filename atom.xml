<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BK的博客</title>
  
  <subtitle>记录成长的轨迹</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.iamlbk.com/"/>
  <updated>2017-10-29T13:31:42.681Z</updated>
  <id>http://blog.iamlbk.com/</id>
  
  <author>
    <name>LBK</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jersey The ResourceConfig instance does not contain any root resource classes</title>
    <link href="http://blog.iamlbk.com/20160904/2016-09-04-jersey-not-contain-root-resource/"/>
    <id>http://blog.iamlbk.com/20160904/2016-09-04-jersey-not-contain-root-resource/</id>
    <published>2016-09-04T13:17:17.000Z</published>
    <updated>2017-10-29T13:31:42.681Z</updated>
    
    <content type="html"><![CDATA[<p>使用jersey框架时遇到了如下错误”The ResourceConfig instance does not contain any root resouce classes”. 下面是这个错误的几种解决办法.</p><ol><li>确认要发布出去的类被<code>@Path</code>注解修饰.</li><li>确认这些在类加载路径里.</li><li>确认web.xml中配置的包名正确.</li><li>这些类需要以class文件的方式放到类路径里, 而不是jar包的方式. 否则可能在Windows上可以正常运行, 到Linux上就无法正常运行了.</li></ol><p>ps: 其实官方文档有这方面的描述, 但是目前还没有看出来需要对jar包做怎样的特殊处理. 等试出来之后再添加上来.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用jersey框架时遇到了如下错误”The ResourceConfig instance does not contain any root resouce classes”. 下面是这个错误的几种解决办法.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;确认要发布出去的类被&lt;code&gt;@
      
    
    </summary>
    
      <category term="工具" scheme="http://blog.iamlbk.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="java" scheme="http://blog.iamlbk.com/tags/java/"/>
    
      <category term="jersey" scheme="http://blog.iamlbk.com/tags/jersey/"/>
    
      <category term="restful" scheme="http://blog.iamlbk.com/tags/restful/"/>
    
  </entry>
  
  <entry>
    <title>tomcat配置https访问方式</title>
    <link href="http://blog.iamlbk.com/20160731/2016-07-31-tomcat-https/"/>
    <id>http://blog.iamlbk.com/20160731/2016-07-31-tomcat-https/</id>
    <published>2016-07-31T00:56:23.000Z</published>
    <updated>2017-12-02T17:07:00.158Z</updated>
    
    <content type="html"><![CDATA[<p>由于项目需要, 学习了一下tomcat配置https访问. 这里简单聊一下tomcat配置https访问的步骤. </p><h2 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h2><p>在浏览器通过https访问网站时, 网站需要出示一个证书证明自己的身份. 因此在配置https访问之前, 我们需要生成一个密钥对. 我们为了省事, 只是简单的自己生成一个密钥对.</p><p>生成密钥对的命令如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">keytool -genkey -<span class="built_in">alias</span> apple -keyalg RSA -sigalg SHA256withRSA -keysize 1024 -validity 36500 -keystore ./keystore</div></pre></td></tr></table></figure><a id="more"></a><ul><li>keytool是java自带的工具. 可以在%JAVA_HOME%/bin目录里找到.</li><li>-alias指定证书的别名</li><li>-keyalg指定密钥算法名称, 这里使用RSA</li><li>-sigalg指定签名算法名称, 这里使用SHA256</li><li>-keysize指定秘钥位数</li><li>-validity指定有效期, 单位为天. 这里指定有效期为36500天, 也就是说大约100年以后会过期.</li><li>-keystore指定密钥库(也是秘钥存储的位置), 本次存储在当前目录的keystore文件中</li></ul><p>输入上面的命令, 回车. 会提示如下内容. (注, 下面’#’号后面为解释)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">输入密钥库口令: <span class="comment"># 输入密钥库密码, 输入密码时不会回显.</span></div><div class="line">再次输入新口令: <span class="comment"># 重复输入上面的密码, 如果密钥库已经存在, 则没有这一步</span></div><div class="line">您的名字与姓氏是什么?</div><div class="line">  [Unknown]: localhost <span class="comment"># 使用这个证书的域名或者IP地址</span></div><div class="line">您的组织单位名称是什么?</div><div class="line">  [Unknown]: Develop <span class="comment"># 随意</span></div><div class="line">您的组织名称是什么?</div><div class="line">  [Unknown]: YH <span class="comment"># 随意</span></div><div class="line">您所在的城市或区域名称是什么?</div><div class="line">  [Unknown]: Beijing <span class="comment"># 随意</span></div><div class="line">您所在的省/市/自治区名称是什么?</div><div class="line">  [Unknown]: Beijing <span class="comment"># 随意</span></div><div class="line">该单位的双字母国家/地区代码是什么?</div><div class="line">  [Unknown]: CN <span class="comment"># 随意</span></div><div class="line">CN=localhost, OU=Develop, O=YH, L=Beijing, ST=Beijing, C=CN是否正确?</div><div class="line">  [否]: y <span class="comment"># 如果上面有个地方写错了, 这里不输入内容直接回车, 会让你再重新输入一遍</span></div><div class="line"></div><div class="line">输入 &lt;apple&gt; 的密钥口令</div><div class="line">        (如果和密钥库口令相同, 按回车): <span class="comment"># 密钥的口令, 这里使用上面密钥库的口令. 必须和密钥库的口令相同</span></div></pre></td></tr></table></figure><p>提示输入名字与姓氏时最好输入域名或者IP, 其他虽然为随意输入, 但是还是建议输入真实的信息</p><p>至此, 密钥就已经保存到了前面指定的文件中. 下面我们修改tomcat的配置文件</p><h2 id="修改tomcat配置"><a href="#修改tomcat配置" class="headerlink" title="修改tomcat配置"></a>修改tomcat配置</h2><p>首先修改tomcat/conf/server.xml文件.<br>将其中port=”8443”对应的标签的注释取消掉, 并将密钥文件路径和密码加到配置中. 如下所示:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8443"</span> <span class="attr">protocol</span>=<span class="string">"org.apache.coyote.http11.Http11NioProtocol"</span></span></div><div class="line"><span class="tag">   <span class="attr">maxThreads</span>=<span class="string">"150"</span> <span class="attr">SSLEnabled</span>=<span class="string">"true"</span> <span class="attr">scheme</span>=<span class="string">"https"</span> <span class="attr">secure</span>=<span class="string">"true"</span></span></div><div class="line"><span class="tag">   <span class="attr">clientAuth</span>=<span class="string">"false"</span> <span class="attr">sslProtocol</span>=<span class="string">"TLS"</span> </span></div><div class="line"><span class="tag">   <span class="attr">keystoreFile</span>=<span class="string">"conf/keystore"</span> </span></div><div class="line"><span class="tag">   <span class="attr">keystorePass</span>=<span class="string">"123456"</span> </span></div><div class="line"><span class="tag"> /&gt;</span></div></pre></td></tr></table></figure><p>此时如果启动tomcat, 并访问<code>http://localhost:8443</code>, 应该出现如下界面:<br><img src="/images/2016/07/tomcat_https_first_visit.png" alt="首次通过https访问页面"></p><p>这时我们点击”继续浏览此网站(不推荐)。”, 即可看到tomcat的首页. 至此tomcat已经支持https方式访问了. 提示证书错误的原因我们后面再说.</p><h2 id="自动切换为https协议"><a href="#自动切换为https协议" class="headerlink" title="自动切换为https协议"></a>自动切换为https协议</h2><p>虽然上面我们已经让tomcat支持https方式访问了. 但是有时候我们还希望用户通过http访问时, 自动切换为https协议. 这个功能也很好实现, 只需要将下面一段xml加入到tomcat/conf/web.xml或者项目的WEB-INF/web.xml文件中即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">security-constraint</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">web-resource-collection</span> &gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">web-resource-name</span> &gt;</span>SSL<span class="tag">&lt;/<span class="name">web-resource-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">web-resource-collection</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">user-data-constraint</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">transport-guarantee</span>&gt;</span>CONFIDENTIAL<span class="tag">&lt;/<span class="name">transport-guarantee</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">user-data-constraint</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">security-constraint</span>&gt;</span></div></pre></td></tr></table></figure><ul><li>如果希望整个tomcat下的所有工程都自动切换为https协议, 那么就需要将上面那段xml放置到tomcat/conf/web.xml文件的<code>web-app</code>标签里</li><li>如果只是希望某个项目能自动切换https协议, 那么修改这个项目的web.xml文件即可</li></ul><h2 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h2><h3 id="浏览器提示”此网站出具的安全证书不是由受信任的证书颁发机构颁发的”"><a href="#浏览器提示”此网站出具的安全证书不是由受信任的证书颁发机构颁发的”" class="headerlink" title="浏览器提示”此网站出具的安全证书不是由受信任的证书颁发机构颁发的”"></a>浏览器提示”此网站出具的安全证书不是由受信任的证书颁发机构颁发的”</h3><p>由于我们的证书只是我们自己生成的, 并没有提交给CA. 因此浏览器会认为我们的证书不安全. 要解决这个问题, 需要从CA机构购买证书. 或者我们可以向12306学习, 将证书导出, 然后交给用户, 让用户将证书加入到”受信任的根证书颁发机构”里即可.<br>导出证书的步骤:</p><p><img src="/images/2016/07/tomcat_https_export_certy1.png" alt="导出证书第一步"><br><img src="/images/2016/07/tomcat_https_export_certy2.png" alt="导出证书第二步"></p><p>安装证书的过程很简单, 这里就不再赘述了. 如果遇到问题, 可以参见12306的安装证书的步骤.</p><h3 id="浏览器提示”此网站出具的安全证书是为其他网站地址颁发的”"><a href="#浏览器提示”此网站出具的安全证书是为其他网站地址颁发的”" class="headerlink" title="浏览器提示”此网站出具的安全证书是为其他网站地址颁发的”"></a>浏览器提示”此网站出具的安全证书是为其他网站地址颁发的”</h3><p>错误信息如下:</p><p><img src="/images/2016/07/tomcat_https_domain_error.png" alt="此网站出具的安全证书是为其他网站地址颁发的"></p><p>原因: 生成密钥文件提示”您的名字与姓氏是什么?”时输入的不是域名. 需要重新生成密钥文件, 并重复执行导出, 安装的过程.</p><h3 id="chrome提示”您与xxx之间的连接采用了过时的加密技术。”"><a href="#chrome提示”您与xxx之间的连接采用了过时的加密技术。”" class="headerlink" title="chrome提示”您与xxx之间的连接采用了过时的加密技术。”"></a>chrome提示”您与xxx之间的连接采用了过时的加密技术。”</h3><p>虽然SHA-1算法目前尚未发现严重的弱点，但伪造证书所需费用正越来越低。因此浏览器都已经不在建议使用SHA-1算法对证书进行签名了. 解决办法就是使用更为安全的SHA-2. 在生成密钥文件时添加<code>-sigalg SHA256withRSA</code>选项即可. 参见<a href="http://docs.oracle.com/javase/7/docs/technotes/tools/windows/keytool.html" title="keytool文档" target="_blank" rel="external">keytool文档</a></p><p>目前还没有从CA机构申请过证书, 流程还不清楚. 等尝试过一次以后, 再更新本博客.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于项目需要, 学习了一下tomcat配置https访问. 这里简单聊一下tomcat配置https访问的步骤. &lt;/p&gt;
&lt;h2 id=&quot;生成证书&quot;&gt;&lt;a href=&quot;#生成证书&quot; class=&quot;headerlink&quot; title=&quot;生成证书&quot;&gt;&lt;/a&gt;生成证书&lt;/h2&gt;&lt;p&gt;在浏览器通过https访问网站时, 网站需要出示一个证书证明自己的身份. 因此在配置https访问之前, 我们需要生成一个密钥对. 我们为了省事, 只是简单的自己生成一个密钥对.&lt;/p&gt;
&lt;p&gt;生成密钥对的命令如下:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;keytool -genkey -&lt;span class=&quot;built_in&quot;&gt;alias&lt;/span&gt; apple -keyalg RSA -sigalg SHA256withRSA -keysize 1024 -validity 36500 -keystore ./keystore&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="工具" scheme="http://blog.iamlbk.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="tomcat" scheme="http://blog.iamlbk.com/tags/tomcat/"/>
    
      <category term="https" scheme="http://blog.iamlbk.com/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>pdf转图片(java语言实现)</title>
    <link href="http://blog.iamlbk.com/20160424/2016-04-24-java-pdf-to-image/"/>
    <id>http://blog.iamlbk.com/20160424/2016-04-24-java-pdf-to-image/</id>
    <published>2016-04-24T12:04:24.000Z</published>
    <updated>2017-12-02T17:12:17.953Z</updated>
    
    <content type="html"><![CDATA[<p>由于项目需要将pdf转成图片, 所以学习了使用java将pdf文件转成图片的方法. 这里记录下方法, 方便以后查阅.</p><p>目前pdf转图片比较常用的类库有如下几个:</p><ul><li><a href="https://java.net/projects/pdf-renderer/" title="PDFRenderer主页" target="_blank" rel="external">PDFRenderer</a>: 开源, 是Swinglabs的一个子项目. 效率较高, 但是无法处理中文.</li><li><a href="http://pdfbox.apache.org/" title="pdfbox主页" target="_blank" rel="external">pdfbox</a>: apache的一个开源项目, 部分支持中文, 有些中文pdf可以正常转换, 有些则完全无法转换, 比较消耗内存.</li><li><a href="https://www.idrsolutions.com/jpedal/" title="jpedal主页" target="_blank" rel="external">jpedal</a>: 据说有开源和商业版本, 但是我只找到了商业版本, 而且价格不菲, 所以并没有试过…</li><li><a href="http://www.icesoft.org/java/home.jsf" title="ICEPDF主页" target="_blank" rel="external">ICEPDF</a>: 有开源和商业版本. 开源的也是部分支持中文, 商业版的没有尝试过.</li></ul><p>上面所说的四种工具, 只有pdfbox能支持项目中用到的中文pdf. 所以我使用的是pdfbox. 但是在解决过问题以后, 我使用其他的pdf文件测试时, 有些中文pdf文件转换过之后就只剩下乱码了. 如果需要完美的中文支持, 可能只有使用 jpedal 或者 ICEPDF 的商业版才行吧?</p><a id="more"></a><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>目前(2016/04/24)pdfbox的最新版本为2.0.0. 我使用的版本为1.8.11. maven坐标如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.pdfbox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pdfbox<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div></pre></td></tr></table></figure><p>也可以直接从pdfbox的下载页面下载: <a href="http://pdfbox.apache.org/download.cgi" target="_blank" rel="external">http://pdfbox.apache.org/download.cgi</a></p><h2 id="将pdf文件转成图片文件"><a href="#将pdf文件转成图片文件" class="headerlink" title="将pdf文件转成图片文件"></a>将pdf文件转成图片文件</h2><p>如果只是需要将pdf文件转成图片文件还是比较简单的, 只需要简单的6,7行代码就行了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BASE_PATH = <span class="string">"F:\\java\\"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    File file = <span class="keyword">new</span> File(BASE_PATH + <span class="string">"test.pdf"</span>);</div><div class="line">    PDDocument doc = PDDocument.load(file);</div><div class="line">    PDFImageWriter imageWriter = <span class="keyword">new</span> PDFImageWriter();</div><div class="line"></div><div class="line">    <span class="keyword">int</span> pageCount = doc.getNumberOfPages();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= pageCount; i++) &#123;</div><div class="line">        <span class="comment">// 将第 i 到 i 页(也就是第i页)转换成图片, 并存到文件中</span></div><div class="line">        imageWriter.writeImage(doc, <span class="string">"jpg"</span>, <span class="keyword">null</span>, i, i, BASE_PATH + file.getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>过程很简单, 加载pdf文件. 创建一个输出流. 遍历pdf文件的每一页, 输出到图片文件中即可.</p><p>其中<code>PDDocument.load</code>有多个重载方法, 最简单的四个重载方法分别接受<code>String</code>类型的参数, <code>File</code>类型的参数; <code>URL</code>类型的参数, 或者<code>InputStream</code>类型的参数.</p><p>而在输出时的<code>imageWrite.writeImage</code>方法的第二个参数指定图片类型, 这个参数也决定了生成图片文件的缩略名.</p><h2 id="将pdf转换成图片-并输出到内存的缓存中"><a href="#将pdf转换成图片-并输出到内存的缓存中" class="headerlink" title="将pdf转换成图片, 并输出到内存的缓存中"></a>将pdf转换成图片, 并输出到内存的缓存中</h2><p>我们可能需要将pdf转换成图片, 并存到内存中进行下一步处理(比如发送给浏览器客户端). 我们当然可以先存到文件中, 然后再读进内存, 但是这样效率太低, 尤其需要读写硬盘. 既然pdfbox有输出到内存缓冲区的功能. 我们当然不能浪费.</p><p>当然为了看到效果, 下面的示例程序还是将图片保存到文件中.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BASE_PATH = <span class="string">"F:\\java\\"</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    File file = <span class="keyword">new</span> File(BASE_PATH + <span class="string">"test.pdf"</span>);</div><div class="line">    PDDocument doc = PDDocument.load(file);</div><div class="line">    List&lt;?&gt; pages = doc.getDocumentCatalog().getAllPages();</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pages.size(); i++) &#123;</div><div class="line">        PDPage page = (PDPage) pages.get(i);   <span class="comment">// 获取第i页</span></div><div class="line">        BufferedImage image = page.convertToImage();</div><div class="line">        </div><div class="line">        <span class="comment">// 输出到文件中</span></div><div class="line">        String outPath = BASE_PATH + file.getName() + i + <span class="string">".gif"</span>;</div><div class="line">        <span class="keyword">try</span> (FileOutputStream out = <span class="keyword">new</span> FileOutputStream(outPath)) &#123;</div><div class="line">            ImageIO.write(image, <span class="string">"gif"</span>, out);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>非常简单吧! 今天就说这么多吧. 需要源码的朋友可以从这里<a href="/downloads/code/2016/04/pdf2image.zip" title="下载代码">下载</a>源码.  如果各位朋友还有什么问题, 可以在下方的留言区留言, 我们相互讨论, 共同进步. </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于项目需要将pdf转成图片, 所以学习了使用java将pdf文件转成图片的方法. 这里记录下方法, 方便以后查阅.&lt;/p&gt;
&lt;p&gt;目前pdf转图片比较常用的类库有如下几个:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://java.net/projects/pdf-renderer/&quot; title=&quot;PDFRenderer主页&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;PDFRenderer&lt;/a&gt;: 开源, 是Swinglabs的一个子项目. 效率较高, 但是无法处理中文.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://pdfbox.apache.org/&quot; title=&quot;pdfbox主页&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;pdfbox&lt;/a&gt;: apache的一个开源项目, 部分支持中文, 有些中文pdf可以正常转换, 有些则完全无法转换, 比较消耗内存.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.idrsolutions.com/jpedal/&quot; title=&quot;jpedal主页&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;jpedal&lt;/a&gt;: 据说有开源和商业版本, 但是我只找到了商业版本, 而且价格不菲, 所以并没有试过…&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.icesoft.org/java/home.jsf&quot; title=&quot;ICEPDF主页&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ICEPDF&lt;/a&gt;: 有开源和商业版本. 开源的也是部分支持中文, 商业版的没有尝试过.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面所说的四种工具, 只有pdfbox能支持项目中用到的中文pdf. 所以我使用的是pdfbox. 但是在解决过问题以后, 我使用其他的pdf文件测试时, 有些中文pdf文件转换过之后就只剩下乱码了. 如果需要完美的中文支持, 可能只有使用 jpedal 或者 ICEPDF 的商业版才行吧?&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://blog.iamlbk.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://blog.iamlbk.com/tags/java/"/>
    
      <category term="pdf2image" scheme="http://blog.iamlbk.com/tags/pdf2image/"/>
    
      <category term="pdfbox" scheme="http://blog.iamlbk.com/tags/pdfbox/"/>
    
  </entry>
  
  <entry>
    <title>简易缓存实现(java语言版)</title>
    <link href="http://blog.iamlbk.com/20160402/2016-04-02-java-simple-cache/"/>
    <id>http://blog.iamlbk.com/20160402/2016-04-02-java-simple-cache/</id>
    <published>2016-04-02T11:45:53.000Z</published>
    <updated>2017-12-02T16:59:33.075Z</updated>
    
    <content type="html"><![CDATA[<p>在合适的地方使用缓存可以 简化程序逻辑 或者 提高程序的效率. 比如前面的<a href="/blog/tags/fa-song-duan-xin/" title="发送短信">发送短信</a>部分中<a href="/blog/20160219/sms-java-code-2/" title="发送短信(二):限制发送频率">限制发送频率</a>和<a href="/blog/20160220/sms-java-code-3/" title="发送短信(三):限制日发送次数">限制日发送次数</a>就可以使用缓存机制实现.这里我们自己实现一个简易版的缓存类. 该类提供如下功能:</p><ul><li>可以添加键值对</li><li>根据键获取对应的值</li><li>超时的键值对会被删除</li><li>可以限制缓冲区的大小</li></ul><a id="more"></a><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>在动手实现之前, 我们首先需要选择合适的数据结构来存储数据. 为了存储键值对, Map是最合适. 为了在删除过期数据时不用遍历整个Map, 我们需要一个优先队列来按照过期时间排序存储键值对. </p><p>但是使用Java提供的<code>PriorityQueue</code>并不合适. 因为虽然<code>PriorityQueue</code>类的<code>remove()</code>方法提供了O(log(n))的时间效率. 但是<code>remove(Object)</code>的效率是O(n)的. 而我们使用优先队列就是为了避免删除时O(n)的时间复杂度.</p><p>这里我们自己实现一个超级简化版的”优先队列”, 如果有更复杂的需求, 使用红黑树, 堆等数据结构可能会更合适一点.</p><h2 id="数据节点"><a href="#数据节点" class="headerlink" title="数据节点"></a>数据节点</h2><p>既然需要实现一个简单的优先队列, 那么就需要先定义一个存储元素的类型. 由于我们不需要随机访问, 而需要方便的扩充容量, 所以使用链表的方式实现. 下面给出我们的优先队列需要存储的数据节点的定义:</p><figure class="highlight java"><figcaption><span>Entity</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 该类是内部类, 所以可以用static关键字修饰</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entity</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> K key;</div><div class="line">    <span class="keyword">private</span> V value;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeout;</div><div class="line">    Entity&lt;K, V&gt; next;</div><div class="line">    Entity&lt;K, V&gt; prev;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Entity</span><span class="params">(K key, V value, <span class="keyword">long</span> liveTime)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.key = key;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">        updateTimeout(liveTime);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 省略了getter, setter方法</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTimeout</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> timeout &lt; System.currentTimeMillis();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateTimeout</span><span class="params">(<span class="keyword">long</span> liveTime)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.timeout = System.currentTimeMillis() + liveTime;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 省略了hashCode, equals方法</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>我们的”优先队列”需要提供那些功能呢? </p><p>首先需要有添加功能, 并且添加后队列中的元素是按照过期时间排序的. 考虑到一般而言, 一个缓冲区中所有的元素的生存周期都是一样的(比如都是20分钟). 所以后面加入的元素的过期时间更靠后, 因此我们只需要提供一个 追加方法 即可.</p><p>需要有删除功能. 由于队列是按照过期时间排序的, 所以在删除时, 我们需要从头开始删除, 因此需要有 获取头部元素 和 删除头部元素 的功能.</p><p>还需要一个更新功能. 当用户使用了某个元素时, 我们需要修改该元素的过期时间, 然后把该元素放到队列的队尾. 当用户更新了和某个key关联的value后我们需要更新<code>Entity</code>中的<code>value</code>和<code>timeout</code>字段, 然后放到队列的队尾. 而这两个需求都可以使用删除再添加实现. 所以我们需要提供一个 删除指定元素 的功能.</p><p>最后, 为了方便, 顺带再提供一个清空功能.</p><p>总结一下. 我们需要的功能有: 追加, 获取头部元素, 删除头部元素, 删除指定元素, 清空. 下面是实现代码:</p><figure class="highlight java"><figcaption><span>Queue</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 该类同样是内部类</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> Entity&lt;K, V&gt; head;</div><div class="line">    <span class="keyword">private</span> Entity&lt;K, V&gt; tail;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">()</span> </span>&#123;</div><div class="line">        head = <span class="keyword">null</span>;</div><div class="line">        tail = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获得第一个元素.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Entity&lt;K, V&gt; <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> head;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 向队列末尾添加元素.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(Entity&lt;K, V&gt; entity)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">            head = entity;</div><div class="line">            tail = entity;</div><div class="line">            entity.prev = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            entity.prev = tail;</div><div class="line">            tail.next = entity;</div><div class="line">            tail = entity;</div><div class="line">        &#125;</div><div class="line">        entity.next = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 移除第一个元素.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Entity&lt;K, V&gt; <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// 没有元素</span></div><div class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        Entity&lt;K, V&gt; entity = head;</div><div class="line"></div><div class="line">        <span class="comment">// 只有一个元素</span></div><div class="line">        <span class="keyword">if</span> (head == tail) &#123;</div><div class="line">            head = <span class="keyword">null</span>;</div><div class="line">            tail = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            head = entity.next;</div><div class="line">            head.prev = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> entity;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 从队列中移除指定的元素. 该元素必须在队列中, 否则会出现无法预期的结果.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Entity&lt;K, V&gt; <span class="title">remove</span><span class="params">(Entity&lt;K, V&gt; entity)</span> </span>&#123;</div><div class="line">        <span class="comment">// 只有一个元素 或者 没有元素</span></div><div class="line">        <span class="keyword">if</span> (head == tail) &#123;</div><div class="line">            head = <span class="keyword">null</span>;</div><div class="line">            tail = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">return</span> entity;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (entity.prev != <span class="keyword">null</span>) &#123;</div><div class="line">            entity.prev.next = entity.next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            head = entity.next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (entity.next != <span class="keyword">null</span>) &#123;</div><div class="line">            entity.next.prev = entity.prev;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            tail = entity.prev;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> entity;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        head = <span class="keyword">null</span>;</div><div class="line">        tail = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="简易缓存实现"><a href="#简易缓存实现" class="headerlink" title="简易缓存实现"></a>简易缓存实现</h2><p>终于到了实现缓存类的时候了. 其实经过上面的准备, 我们的缓存实现起来并不麻烦. 首先给出该类的属性以及构造方法:</p><figure class="highlight java"><figcaption><span>SimpleCache构造方法</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">long</span> liveTime;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> limit;</div><div class="line"><span class="keyword">private</span> Map&lt;K, Entity&lt;K, V&gt;&gt; map;</div><div class="line"><span class="keyword">private</span> Queue&lt;K, V&gt; queue;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleCache</span><span class="params">(<span class="keyword">long</span> liveTime)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(liveTime, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleCache</span><span class="params">(<span class="keyword">long</span> liveTime, <span class="keyword">int</span> limit)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.liveTime = liveTime;</div><div class="line">    <span class="keyword">this</span>.limit = limit &gt; <span class="number">0</span> ? limit : <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> initialCapacity = limit == <span class="number">0</span> ? <span class="number">16</span> : (<span class="keyword">int</span>) (limit * <span class="number">0.8</span>);</div><div class="line">    <span class="keyword">this</span>.map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</div><div class="line">    <span class="keyword">this</span>.queue = <span class="keyword">new</span> Queue&lt;&gt;();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>接下来我们先实现删除过期数据的方法:<br><figure class="highlight java"><figcaption><span>SimpleCache.removeTimeOut</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeTimeOut</span><span class="params">()</span> </span>&#123;</div><div class="line">    Entity&lt;K, V&gt; head = queue.getFirst();</div><div class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span> &amp;&amp; head.isTimeout()) &#123;</div><div class="line">        removeFirst();</div><div class="line">        head = queue.getFirst();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><code>removeFirst</code>方法的实现就更简单了:<br><figure class="highlight java"><figcaption><span>SimpleCache.removeFirst</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 注意, 调用该方法之前需要保证缓冲区中有元素</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">removeFirst</span><span class="params">()</span></span>&#123;</div><div class="line">    map.remove(queue.removeFirst().getKey());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>接着我们实现添加键值对功能. 该功能将一对键值对添加到缓冲区. 如果提供的键已经有与之关联的值了, 那么就用新值将旧值替换掉:<br><figure class="highlight java"><figcaption><span>SimpleCache.add</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">add</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    removeTimeOut();</div><div class="line"></div><div class="line">    Entity&lt;K, V&gt; entity = <span class="keyword">new</span> Entity&lt;&gt;(key, value, liveTime);</div><div class="line">    Entity&lt;K, V&gt; oldEntity = map.put(key, entity);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (oldEntity != <span class="keyword">null</span>) &#123;</div><div class="line">        queue.remove(oldEntity);</div><div class="line">    &#125;</div><div class="line">    queue.append(entity);</div><div class="line"></div><div class="line">    <span class="comment">// 删除多余的缓存</span></div><div class="line">    <span class="keyword">if</span> (limit != <span class="number">0</span> &amp;&amp; map.size() &gt; limit) &#123;</div><div class="line">        removeFirst();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> oldEntity == <span class="keyword">null</span> ? <span class="keyword">null</span> : oldEntity.getValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>获取方法. 获取与指定键关联的值, 并更新该键值对的过期时间:<br><figure class="highlight java"><figcaption><span>SimpleCache.get</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</div><div class="line">    removeTimeOut();</div><div class="line">    Entity&lt;K, V&gt; entity = map.get(key);</div><div class="line">    <span class="keyword">if</span> (entity != <span class="keyword">null</span>) &#123;</div><div class="line">        access(entity);</div><div class="line">        <span class="keyword">return</span> entity.getValue();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p><code>access</code>方法用于更新实体的过期时间, 并调整该实体在队列中的位置:<br><figure class="highlight java"><figcaption><span>SimpleCache.access</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(Entity&lt;K, V&gt; entity)</span> </span>&#123;</div><div class="line">    queue.remove(entity);</div><div class="line">    entity.updateTimeout(liveTime);</div><div class="line">    queue.append(entity);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>最后再提供两个工具方法:<br><figure class="highlight java"><figcaption><span>SimpleCache.clear&size</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">    map.clear();</div><div class="line">    queue.clear();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</div><div class="line">    removeTimeOut();</div><div class="line">    <span class="keyword">return</span> map.size();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>至此, 我们的简易版缓存类就算是完成了. 需要完整代码的朋友可以点击<a href="/downloads/code/2016/04/simpleCache.zip" title="下载代码">这里</a>下载代码.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在合适的地方使用缓存可以 简化程序逻辑 或者 提高程序的效率. 比如前面的&lt;a href=&quot;/blog/tags/fa-song-duan-xin/&quot; title=&quot;发送短信&quot;&gt;发送短信&lt;/a&gt;部分中&lt;a href=&quot;/blog/20160219/sms-java-code-2/&quot; title=&quot;发送短信(二):限制发送频率&quot;&gt;限制发送频率&lt;/a&gt;和&lt;a href=&quot;/blog/20160220/sms-java-code-3/&quot; title=&quot;发送短信(三):限制日发送次数&quot;&gt;限制日发送次数&lt;/a&gt;就可以使用缓存机制实现.这里我们自己实现一个简易版的缓存类. 该类提供如下功能:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以添加键值对&lt;/li&gt;
&lt;li&gt;根据键获取对应的值&lt;/li&gt;
&lt;li&gt;超时的键值对会被删除&lt;/li&gt;
&lt;li&gt;可以限制缓冲区的大小&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="算法" scheme="http://blog.iamlbk.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="java" scheme="http://blog.iamlbk.com/tags/java/"/>
    
      <category term="缓存" scheme="http://blog.iamlbk.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>junit5预览</title>
    <link href="http://blog.iamlbk.com/20160313/2016-03-13-junit5-preview/"/>
    <id>http://blog.iamlbk.com/20160313/2016-03-13-junit5-preview/</id>
    <published>2016-03-13T09:49:35.000Z</published>
    <updated>2017-12-02T16:58:19.249Z</updated>
    
    <content type="html"><![CDATA[<p>junit是最常用的java单元测试框架之一. 目前junit5已经推出了5.0.0 Alpha版, 那么junit5相对于junit4有什么变化呢? 有什么新特性呢? 在这里我们聊一下junit5的变化和新特性.</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="junit-5主页"><a href="#junit-5主页" class="headerlink" title="junit 5主页"></a>junit 5主页</h3><p>在介绍junit 5的新特性之前先给出几个链接. 有兴趣的朋友可以去看看:</p><ul><li>junit 5主页: <a href="http://junit.org/junit5/" target="_blank" rel="external">http://junit.org/junit5/</a></li><li>junit 5用户指南: <a href="http://junit.org/junit5/docs/current/user-guide/" target="_blank" rel="external">http://junit.org/junit5/docs/current/user-guide/</a></li><li>junit 5示例: <a href="https://github.com/junit-team/junit5-samples" target="_blank" rel="external">https://github.com/junit-team/junit5-samples</a></li></ul><a id="more"></a><h3 id="Java版本"><a href="#Java版本" class="headerlink" title="Java版本"></a>Java版本</h3><p>junit 5只支持java 8及以上. 按照《<a href="http://junit.org/junit5/docs/current/user-guide/" title="junit 5用户指南" target="_blank" rel="external">junit 5用户指南</a>》的说法, junit 5也可以测试低版本jdk编译的java类.</p><h3 id="Maven坐标"><a href="#Maven坐标" class="headerlink" title="Maven坐标"></a>Maven坐标</h3><p>junit 5已经不再是单个库了, 而是模块化结构的集合. 所有的模块可以参见《<a href="http://junit.org/junit5/docs/current/user-guide/" title="junit 5用户指南" target="_blank" rel="external">junit 5用户指南</a>》. 这里我们给出一般情况下需要依赖的junit 5的包的Maven坐标:</p><p>Group ID: org.junit <br><br>Artifact ID: junit5-api <br><br>Version: 5.0.0-SNAPSHOT</p><h2 id="包-类变化"><a href="#包-类变化" class="headerlink" title="包/类变化"></a>包/类变化</h2><ul><li>注解移动到了<code>org.junit.gen5.api</code>包中</li><li>断言移动到了<code>org.junit.gen5.api.Assertions</code>类中</li><li>假设移动到了<code>org.junit.gen5.api.Assumptions</code>类中</li></ul><h2 id="注解变化"><a href="#注解变化" class="headerlink" title="注解变化"></a>注解变化</h2><ul><li><code>@Test</code>注解已经不再包含任何的属性了.</li><li><code>@Before</code>和<code>@After</code>已经删除了, 与之对应的替代注解分别是<code>@BeforeEach</code>和<code>@AfterEach</code></li><li><code>@BeforeClass</code>和<code>@AfterClass</code>也不存在了, 可以使用<code>@BeforeAll</code>和<code>@AfterAll</code>代替</li><li><code>@Ignore</code>被<code>@Disabled</code>代替</li><li><code>@Category</code>使用<code>@Tag</code>代替</li><li><code>@RunWith</code>使用<code>@ExtendWith</code>代替</li><li>更多的信息请参见《<a href="http://junit.org/junit5/docs/current/user-guide/" title="junit 5用户指南" target="_blank" rel="external">junit 5用户指南</a>》</li></ul><h2 id="第一个测试方法"><a href="#第一个测试方法" class="headerlink" title="第一个测试方法"></a>第一个测试方法</h2><p>下面我们用junit 5编写一个最简单的单元测试:</p><figure class="highlight java"><figcaption><span>Junit5FirstTest.java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Junit5FirstTest</span></span>&#123;</div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">myFirstTest</span><span class="params">()</span> </span>&#123;</div><div class="line">        assertEquals(<span class="number">2</span>, <span class="number">1</span> + <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意到了吗? 我们的测试类和方法都没有用<code>public</code>修饰. 在junit 5中只要测试方法没有用<code>private</code>修饰就可以.</p><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>由于junit 5需要的jre版本为java 8. 自然就可以在特定地方使用Lambda表达式. 这里我们在断言中使用一次Lambda表达式:</p><figure class="highlight java"><figcaption><span>Junit5FirstTest.java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">testLambda</span><span class="params">()</span></span>&#123;</div><div class="line">    assertTrue(<span class="number">1</span> == <span class="number">1</span>, () -&gt; <span class="string">"1竟然不等于1..."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>我们可以看一下<code>assertTrue</code>方法的签名就清楚是怎么回事了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assertTrue</span><span class="params">(<span class="keyword">boolean</span> condition)</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="comment">// 我们调用的是下面的方法</span></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assertTrue</span><span class="params">(<span class="keyword">boolean</span> condition, Supplier&lt;String&gt; messageSupplier)</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assertTrue</span><span class="params">(BooleanSupplier booleanSupplier)</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assertTrue</span><span class="params">(BooleanSupplier booleanSupplier, String message)</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assertTrue</span><span class="params">(<span class="keyword">boolean</span> condition, String message)</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assertTrue</span><span class="params">(BooleanSupplier booleanSupplier, Supplier&lt;String&gt; messageSupplier)</span></span></div></pre></td></tr></table></figure><p>注: 其中的<code>Supplier</code>和<code>BooleanSupplier</code>都在<code>java.util.function</code>包中, 是java 8引入的接口. 这两个接口都是函数式接口, 所以可以使用Lambda表达式简化调用.</p><h2 id="断言分组"><a href="#断言分组" class="headerlink" title="断言分组"></a>断言分组</h2><p>断言分组可以执行一组短信, 之后一起报告. 这样我们或许可以省掉不少的错误信息字符串.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">testGroup</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</div><div class="line">    assertAll(<span class="string">"分组测试失败"</span>,</div><div class="line">        () -&gt; assertTrue(array.length == <span class="number">2</span>),</div><div class="line">        () -&gt; assertTrue(array[<span class="number">0</span>] == <span class="number">1</span>),</div><div class="line">        () -&gt; assertTrue(array[<span class="number">1</span>] == <span class="number">2</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="异常断言"><a href="#异常断言" class="headerlink" title="异常断言"></a>异常断言</h2><p>在junit 4中如果想要判断异常, 就需要在<code>@Test</code>注解中添加expected属性或者使用try-catch包裹. 但是try-catch太繁琐, 而有时候第一种方法又不是很合适. 在Junit 5可以使用异常断言解决:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">testException</span><span class="params">()</span></span>&#123;</div><div class="line">    assertThrows(Exception.class, () -&gt; &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="假设、标签以及禁用测试"><a href="#假设、标签以及禁用测试" class="headerlink" title="假设、标签以及禁用测试"></a>假设、标签以及禁用测试</h2><p>在Junit 5中假设使用<code>org.junit.gen5.api.Assumptions</code>类中的方法完成, 如果假设的条件没有满足, 那么就会跳过测试方法. <code>@Tag</code>注解用来对测试分组, 之后可以方便的指定需要执行那个分组的测试方法. 禁用测试使用<code>@Disabled</code>注解实现, 被该注解标注的方法/类将直接跳过执行.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">testAssumption</span><span class="params">()</span> </span>&#123;</div><div class="line">    assumeTrue(System.getenv(<span class="string">"OS"</span>).startsWith(<span class="string">"Windows"</span>), <span class="string">"跳过测试"</span>);</div><div class="line">    <span class="comment">// 只有在Windows下才会执行下面的代码</span></div><div class="line">    <span class="comment">// 在其他平台下将会跳过该方法, 也不会报错</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="meta">@Tag</span>(<span class="string">"tag1"</span>)</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">testTag</span><span class="params">()</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="meta">@Disabled</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">testWillBeSkipped</span><span class="params">()</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>扩展模型: junit 5修改了扩展模型, 新的扩展模型允许类上注册多种扩展.</li><li>嵌套测试: junit 5中允许在一个测试类中创建一个内部测试类</li><li>方法参数: junit 5中测试方法可以拥有特定类型的参数, junit将进行依赖注入.</li></ul><p>junit 5还有一些有趣的新特性, 这里限于篇幅就不再说了, 感兴趣的朋友可以参见《<a href="http://junit.org/junit5/docs/current/user-guide/" title="junit 5用户指南" target="_blank" rel="external">junit 5用户指南</a>》.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;junit是最常用的java单元测试框架之一. 目前junit5已经推出了5.0.0 Alpha版, 那么junit5相对于junit4有什么变化呢? 有什么新特性呢? 在这里我们聊一下junit5的变化和新特性.&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;h3 id=&quot;junit-5主页&quot;&gt;&lt;a href=&quot;#junit-5主页&quot; class=&quot;headerlink&quot; title=&quot;junit 5主页&quot;&gt;&lt;/a&gt;junit 5主页&lt;/h3&gt;&lt;p&gt;在介绍junit 5的新特性之前先给出几个链接. 有兴趣的朋友可以去看看:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;junit 5主页: &lt;a href=&quot;http://junit.org/junit5/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://junit.org/junit5/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;junit 5用户指南: &lt;a href=&quot;http://junit.org/junit5/docs/current/user-guide/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://junit.org/junit5/docs/current/user-guide/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;junit 5示例: &lt;a href=&quot;https://github.com/junit-team/junit5-samples&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/junit-team/junit5-samples&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://blog.iamlbk.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://blog.iamlbk.com/tags/java/"/>
    
      <category term="junit" scheme="http://blog.iamlbk.com/tags/junit/"/>
    
      <category term="单元测试" scheme="http://blog.iamlbk.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>发送短信(四):使用Redis限制发送频率和日发送次数</title>
    <link href="http://blog.iamlbk.com/20160302/2016-03-02-sms-java-code-with-redis/"/>
    <id>http://blog.iamlbk.com/20160302/2016-03-02-sms-java-code-with-redis/</id>
    <published>2016-03-02T09:26:33.000Z</published>
    <updated>2017-12-02T16:55:42.359Z</updated>
    
    <content type="html"><![CDATA[<p>在前几篇文章中, 我们介绍了限制发送短信频率, 限制日发送次数等功能. 但是后来<a href="http://my.csdn.net/zzg1229059735" title="z-oneC在CSDN上的个人主页" target="_blank" rel="external">z-oneC</a>说用Redis实现会更简单. 于是这几天我大致学了一下Redis, 然后使用Redis重新实现了一次. 当然由于刚接触Redis, 或许有些地方并不合适, 还请您在留言区留言, BK在这里先谢过了.</p><p>其实使用Redis确实挺简单, 至少没有过于复杂的概念, 庞大的命令集. 基本上入门挺快的. 剩下的就是创造力和经验了. 这里我们使用Redis来完成前两篇:《<a href="http://iamlbk.github.io/blog/20160219/sms-java-code-2/" title="发送短信--限制发送频率" target="_blank" rel="external">发送短信–限制发送频率</a>》、《<a href="http://iamlbk.github.io/blog/20160220/sms-java-code-3/" title="发送短信--限制日发送次数" target="_blank" rel="external">发送短信–限制日发送次数</a>》完成的功能.</p><p>当然, 如果读者并没有学过Redis, 可以参见《<a href="https://github.com/JasonLai256/the-little-redis-book/blob/master/cn/redis.md" title="The Little Redis Book" target="_blank" rel="external">The Little Redis Book</a>》快速入门,这本”书”基本上半个上午就可以看完.</p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这里我们就是简单用Redis限制”访问”频率: </p><ul><li>首先根据用户手机号/IP拼凑出一个字符串的关键字. </li><li>然后判断该字符串的值是否为空.<ul><li>如果为空, 则设置该字符串的值为1, 并设置生存时间. 并允许”访问”.</li><li>如果不为空, 则将值加一, 然后判断值是否超过使用期限时间内的最大”访问”次数<ul><li>如果没有超过, 则允许”访问”</li><li>否则拒绝”访问”</li></ul></li></ul></li></ul><h2 id="编写脚本"><a href="#编写脚本" class="headerlink" title="编写脚本"></a>编写脚本</h2><p><strong><em>注: 该脚本摘自《Redis入门指南》</em></strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">--[[</span></div><div class="line"><span class="comment">实现访问频率的脚本.</span></div><div class="line"><span class="comment">参数:</span></div><div class="line"><span class="comment">    KEY[1] 用来标识同一个用户的id</span></div><div class="line"><span class="comment">    ARGV[1] 过期时间</span></div><div class="line"><span class="comment">    ARGV[2] 过期时间内可以访问的次数</span></div><div class="line"><span class="comment">返回值: 如果没有超过指定的频率, 则返回1; 否则返回0</span></div><div class="line"><span class="comment">]]</span></div><div class="line"><span class="keyword">local</span> times = redis.call(<span class="string">'incr'</span>, KEYS[<span class="number">1</span>])</div><div class="line"></div><div class="line"><span class="keyword">if</span> times == <span class="number">1</span> <span class="keyword">then</span></div><div class="line">    <span class="comment">-- 说明刚创建, 设置生存时间</span></div><div class="line">    redis.call(<span class="string">'expire'</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>])</div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> times &gt; <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>]) <span class="keyword">then</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span></div><div class="line"><span class="keyword">end</span></div><div class="line"></div><div class="line"><span class="keyword">return</span> <span class="number">1</span></div></pre></td></tr></table></figure><p>该脚本也比较直观: </p><ul><li>首先将指定的键加一. 由于Redis的特性, 如果指定的键并不存在, 则默认为0, 并加一. 这一步相当于判断指定的键是否存在, 如果不存在, 则置指定的键为1; 否则加一</li><li>接着判断是否是第一次访问, 如果是, 则设置生存时间</li><li>最后判断是否超过了访问频率, 如果超过了访问频率, 则返回0; 否则返回1</li></ul><h2 id="使用Jedis调用脚本"><a href="#使用Jedis调用脚本" class="headerlink" title="使用Jedis调用脚本"></a>使用Jedis调用脚本</h2><p>在Redis的<a href="http://redis.io" title="Redis官网" target="_blank" rel="external">官网</a>上有许多Redis的<a href="http://redis.io/clients#java" title="Reids的Java客户端库" target="_blank" rel="external">Java客户端的库</a>. 这里我们使用<a href="https://github.com/xetorthio/jedis" title="Jedis下载" target="_blank" rel="external">Jedis</a>.</p><p>我们来看看代码. <strong>该程序中的<code>ClassPathResource</code>和<code>FileCopyUtils</code>类为Spring中的类, 因此这里的示例程序依赖于Spring</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimit</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> JedisPool jedisPool;</div><div class="line">    <span class="keyword">private</span> String script;</div><div class="line">    <span class="comment">// 省略了构造方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"script/ratelimiting.lua"</span>);</div><div class="line">        script = FileCopyUtils.copyToString(<span class="keyword">new</span> EncodedResource(resource, <span class="string">"UTF-8"</span>).getReader());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 提供限制速率的功能</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> key        关键字</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 过期时间</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> count      在过期时间内可以访问的次数</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 没有超过指定次数则返回true, 否则返回false</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExceedRate</span><span class="params">(String key, <span class="keyword">long</span> expireTime, <span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; params = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        params.add(Long.toString(expireTime));</div><div class="line">        params.add(Integer.toString(count));</div><div class="line">        <span class="keyword">try</span>(Jedis jedis = jedisPool.getResource()) &#123;</div><div class="line">            List&lt;String&gt; keys = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span>);</div><div class="line">            keys.add(key);</div><div class="line">            Long canSend = (Long) jedis.eval(script, keys, params);</div><div class="line">            <span class="keyword">return</span> canSend == <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里的<code>init</code>方法的作用就是将刚才我们写的脚本读取到<code>script</code>变量中, 以便以后使用.</p><p><code>isExceedRate</code>方法将关键字和参数(过期时间和发送次数)分别封装到<code>List</code>里, 之后使用Jedis调用脚本. 获取返回值, 判断频率是否过高. </p><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>下面我们使用上面的代码完成限制发送频率的功能(部分接口和类的声明请参见《[发送短信–限制发送频率][sms2]》). 限制日发送次数的代码基本相同, 这里就不贴了, 请<a href="/downloads/code/2016/03/sms4.zip" title="下载源码">下载</a>源码查看.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FrequencyFilter</span> <span class="keyword">implements</span> <span class="title">SmsFilter</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String KEY_PREFIX = <span class="string">"rate.frequency.limiting:"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> RateLimit rateLimit;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sendInterval;</div><div class="line"></div><div class="line">    <span class="comment">// 省略了部分代码</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(Sms sms)</span> <span class="keyword">throws</span> FrequentlyException </span>&#123;</div><div class="line">        <span class="keyword">if</span>(rateLimit.isExceedRate(KEY_PREFIX+sms.getMobile(), sendInterval, <span class="number">1</span>)</div><div class="line">                || rateLimit.isExceedRate(KEY_PREFIX+sms.getIp(), sendInterval, <span class="number">1</span>))&#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FrequentlyException(<span class="string">"发送短信过于频繁"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>到这里我们的主要代码就完成了, 可以看出使用Redis后代码确实非常的简单. </p><p>由于我现在还不会性能测试, 所以只是简单的使用<code>for</code>循环测试了一下性能, 虽然可能不是很准确, 但是也有一定的可信度. 在限制发送频率时, 使用<code>ConcurrentMap</code>的性能更高, 貌似比例还不小, 只是由于基数并不大, 所以并没有多费多少时间(十万条记录只多花费了十五秒).<br>但是在限制日发送次数时, 剩下了n多时间. 综合来看, 还是只使用Redis更省时省事.<br>而且, 个人猜测, 在扩展到集群时, 使用Redis应该会简单些. </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前几篇文章中, 我们介绍了限制发送短信频率, 限制日发送次数等功能. 但是后来&lt;a href=&quot;http://my.csdn.net/zzg1229059735&quot; title=&quot;z-oneC在CSDN上的个人主页&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;z-oneC&lt;/a&gt;说用Redis实现会更简单. 于是这几天我大致学了一下Redis, 然后使用Redis重新实现了一次. 当然由于刚接触Redis, 或许有些地方并不合适, 还请您在留言区留言, BK在这里先谢过了.&lt;/p&gt;
&lt;p&gt;其实使用Redis确实挺简单, 至少没有过于复杂的概念, 庞大的命令集. 基本上入门挺快的. 剩下的就是创造力和经验了. 这里我们使用Redis来完成前两篇:《&lt;a href=&quot;http://iamlbk.github.io/blog/20160219/sms-java-code-2/&quot; title=&quot;发送短信--限制发送频率&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;发送短信–限制发送频率&lt;/a&gt;》、《&lt;a href=&quot;http://iamlbk.github.io/blog/20160220/sms-java-code-3/&quot; title=&quot;发送短信--限制日发送次数&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;发送短信–限制日发送次数&lt;/a&gt;》完成的功能.&lt;/p&gt;
&lt;p&gt;当然, 如果读者并没有学过Redis, 可以参见《&lt;a href=&quot;https://github.com/JasonLai256/the-little-redis-book/blob/master/cn/redis.md&quot; title=&quot;The Little Redis Book&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;The Little Redis Book&lt;/a&gt;》快速入门,这本”书”基本上半个上午就可以看完.&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://blog.iamlbk.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://blog.iamlbk.com/tags/java/"/>
    
      <category term="发送短信" scheme="http://blog.iamlbk.com/tags/%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1/"/>
    
      <category term="redis" scheme="http://blog.iamlbk.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>发送短信(三):限制日发送次数</title>
    <link href="http://blog.iamlbk.com/20160220/2016-02-20-sms-java-code-3/"/>
    <id>http://blog.iamlbk.com/20160220/2016-02-20-sms-java-code-3/</id>
    <published>2016-02-20T06:58:41.000Z</published>
    <updated>2017-12-02T16:52:46.231Z</updated>
    
    <content type="html"><![CDATA[<p>在前两篇文章中, 我们实现了同步/异步发送短信以及限制发送短信频率.这一篇, 我们介绍一下限制每日向同一个用户(根据手机号和ip判断)发送短信的次数</p><h2 id="数据表结构"><a href="#数据表结构" class="headerlink" title="数据表结构"></a>数据表结构</h2><p>由于需要记录整天的发送记录, 因此这里我们将数据保存到数据库中. 数据表结构如下:<br><img src="/images/2016/02/sms-java-code-3-dbtable.png" class="center"></p><a id="more"></a><ul><li>type为验证码的类型, 比如注册, 重置密码等. </li><li>sendTime的默认值为当前时间.</li></ul><h2 id="限制日发送次数"><a href="#限制日发送次数" class="headerlink" title="限制日发送次数"></a>限制日发送次数</h2><p>我们这里需要用到<a href="/blog/20160219/sms-java-code-2/" title="发送短信--限制发送频率">上一篇</a>中提到的接口和实体类.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DailyCountFilter</span> <span class="keyword">implements</span> <span class="title">SmsFilter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ipDailyMaxSendCount;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mobileDailyMaxSendCount;</div><div class="line">    <span class="keyword">private</span> SmsDao smsDao;</div><div class="line"></div><div class="line">    <span class="comment">// 省略了部分无用代码</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(SmsEntity smsEntity)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (smsDao.getMobileCount(smsEntity.getMobile()) &gt;= mobileDailyMaxSendCount) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (smsDao.getIPCount(smsEntity.getIp()) &gt;= ipDailyMaxSendCount) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        smsDao.saveEntity(smsEntity);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>主要代码很简单, 首先判断向指定的手机号发送的次数是否达到了日最大发送次数, 之后再判断指定的ip请求发送的次数是否达到了最大次数. 如果都没有, 则将本次发送的手机号, ip等信息保存到数据库中.</p><p>当然, 这个类存在一定的问题: 在判断是否超过最大次数到保存实体数据之间可能已经有其他线程保存了新的数据. 造成上面的两个判断并不是绝对的准确. </p><p>我们可以使用序列化等级的事务保证不会发生错误, 但是代价太高. 因此我们这里不做处理. 因为我们前面已经实现了限制发送频率. 如果先使用<code>FrequencyFilter</code>过滤一次, 限制发送频率, 那么基本上不可能出现前面说的问题.</p><p>还有一个问题: 随着时间的推移, 这个表会越来越大, 造成查询的性能相当的差. 我们可以向上一篇中那样, 每隔一段时间就删除无用的数据; 也可以动态的创建表, 然后向新表中插入数据. </p><h2 id="使用动态表"><a href="#使用动态表" class="headerlink" title="使用动态表"></a>使用动态表</h2><p>这里我们采用第二种方案: 数据表的名字为”sms_四位年_两位月”, 比如”sms_2016_02”. 插入数据时根据现在的时间获得表名, 然后再插入. 另外使用<a href="http://www.quartz-scheduler.org/" title="Quartz官网" target="_blank" rel="external">Quartz</a>在每月的20号2点生成下个月以及下下个月的数据表:</p><p>我们首先修改<code>DailyCountFilter</code>类, 在这个类中添加任务计划, 定时生成数据表:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在上面代码的基础上, 再添加如下代码</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DailyCountFilter</span> <span class="keyword">implements</span> <span class="title">SmsFilter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Scheduler sched;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> SchedulerException </span>&#123;</div><div class="line">        smsDao.createTable(<span class="number">0</span>);  <span class="comment">// 创建这个月的数据表</span></div><div class="line">        smsDao.createTable(<span class="number">1</span>);  <span class="comment">// 创建下个月的数据表</span></div><div class="line">        </div><div class="line">        SchedulerFactory sf = <span class="keyword">new</span> StdSchedulerFactory();</div><div class="line">        sched = sf.getScheduler();  <span class="comment">// 创建Quartz容器</span></div><div class="line">        </div><div class="line">        JobDataMap jobDataMap = <span class="keyword">new</span> JobDataMap();</div><div class="line">        jobDataMap.put(<span class="string">"smsDao"</span>, smsDao);   <span class="comment">// 创建运行任务时需要使用的数据map </span></div><div class="line"></div><div class="line">        <span class="comment">// 创建job对象, 该对象执行实际的任务</span></div><div class="line">        JobDetail job = JobBuilder.newJob(CreateSmsTableJob.class)</div><div class="line">                .usingJobData(jobDataMap)</div><div class="line">                .withIdentity(<span class="string">"create sms table job"</span>).build(); </div><div class="line"></div><div class="line">        <span class="comment">// 创建trigger对象, 该对象用来描述触发执行job的时间规则</span></div><div class="line">        <span class="comment">// 比如这里的每月20号2点</span></div><div class="line">        CronTrigger trigger = TriggerBuilder.newTrigger()</div><div class="line">                .withIdentity(<span class="string">"create sms table trigger"</span>)</div><div class="line">                .withSchedule(CronScheduleBuilder.cronSchedule(<span class="string">"0 0 2 20 * ?"</span>))<span class="comment">// 每月的20号2点</span></div><div class="line">                .build(); </div><div class="line"></div><div class="line">        sched.scheduleJob(job, trigger);    <span class="comment">// 注册任务和触发规则</span></div><div class="line">        sched.start();  <span class="comment">// 启动调度</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            sched.shutdown();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">catch</span> (SchedulerException e) &#123;&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CreateSmsTableJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</div><div class="line">            JobDataMap dataMap = context.getJobDetail().getJobDataMap();</div><div class="line">            SmsDao smsDao = (SmsDao) dataMap.get(<span class="string">"smsDao"</span>); <span class="comment">// 获得传过来的smsDao对象</span></div><div class="line">            smsDao.createTable(<span class="number">1</span>);  <span class="comment">// 创建下个月的数据表</span></div><div class="line">            smsDao.createTable(<span class="number">2</span>);  <span class="comment">// 创建下下个月的数据表</span></div><div class="line">         &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>接下来, 我们看看<code>SmsDao</code>的部分代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsDao</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 创建新的日志表</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> monthExcursion 偏移的月数</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createTable</span><span class="params">(<span class="keyword">int</span> monthExcursion)</span></span>&#123;</div><div class="line">        String sql = <span class="string">"CREATE TABLE IF NOT EXISTS "</span> </div><div class="line">            + getTableName(monthExcursion) + <span class="string">" LIKE sms"</span>;</div><div class="line">        <span class="comment">// 执行sql语句</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 保存SmsEntity实体对象</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveEntity</span><span class="params">(SmsEntity smsEntity)</span></span>&#123;</div><div class="line">        String sql = <span class="string">"INSERT INTO "</span> </div><div class="line">            + getNowTableName() + <span class="string">" (mobile, ip, type) VALUES(?, ?, ?)"</span>;</div><div class="line">        <span class="comment">// 执行sql语句</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获得指定手机号今天请求发送短信的次数</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> mobile 用户手机号</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 今天请求发送短信的次数</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getMobileCount</span><span class="params">(String mobile)</span></span>&#123;</div><div class="line">        String sql = <span class="string">"SELECT count(id) FROM "</span></div><div class="line">            + getNowTableName() + <span class="string">" WHERE mobile=? AND send_time &gt;= CURDATE()"</span>;</div><div class="line">        <span class="comment">// 执行sql语句, 返回查询结果</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 省略了getIPCount方法</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获得现在使用的表的名字</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getNowTableName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> getTableName(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> DateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy_MM"</span>);</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 获得相对现在偏移monthExcursion月的表名</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> monthExcursion 偏移的月数</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 对应月的表名</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getTableName</span><span class="params">(<span class="keyword">int</span> monthExcursion)</span> </span>&#123;</div><div class="line">        Calendar calendar = Calendar.getInstance();</div><div class="line">        calendar.add(Calendar.MONTH, monthExcursion);</div><div class="line">        Date date = calendar.getTime();</div><div class="line">        <span class="keyword">return</span> <span class="string">"sms_"</span> + dateFormat.format(date);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>SmsDao</code>中的<code>createTable</code>方法成功运行有个前提, 就是存在<code>sms</code>数据表. <code>createTable</code>方法会复制<code>sms</code>表的结构创建新的数据表.</p><p>我们保留发送短信的数据(手机号, ip, 时间等), 而不是直接删除, 是因为以后可能需要分析这些数据, 获取我们想要的信息, 比如判断服务商短信的到达率、是否有人恶意发送短信等. 甚至可能获得意外的”惊喜”. </p><p>最后, 示例代码可以在<a href="/downloads/code/2016/02/sms3.zip" title="下载源码">这里</a>下载.</p><p>发送短信文章:</p><ul><li><a href="/blog/20160219/sms-java-code-1/" title="发送短信--同步/异步发送短信">发送短信–同步/异步发送短信</a>: <a href="http://www.iamlbk.com/blog/20160219/sms-java-code-1/" target="_blank" rel="external">http://www.iamlbk.com/blog/20160219/sms-java-code-1/</a></li><li><a href="/blog/20160219/sms-java-code-2/" title="发送短信--限制发送频率">发送短信–限制发送频率</a>:  <a href="http://www.iamlbk.com/blog/20160219/sms-java-code-2/" target="_blank" rel="external">http://www.iamlbk.com/blog/20160219/sms-java-code-2/</a></li><li><a href="/blog/20160219/sms-java-code-3/" title="发送短信--限制日发送次数">发送短信–限制日发送次数</a>: <a href="http://www.iamlbk.com/blog/20160219/sms-java-code-3/" target="_blank" rel="external">http://www.iamlbk.com/blog/20160219/sms-java-code-3/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前两篇文章中, 我们实现了同步/异步发送短信以及限制发送短信频率.这一篇, 我们介绍一下限制每日向同一个用户(根据手机号和ip判断)发送短信的次数&lt;/p&gt;
&lt;h2 id=&quot;数据表结构&quot;&gt;&lt;a href=&quot;#数据表结构&quot; class=&quot;headerlink&quot; title=&quot;数据表结构&quot;&gt;&lt;/a&gt;数据表结构&lt;/h2&gt;&lt;p&gt;由于需要记录整天的发送记录, 因此这里我们将数据保存到数据库中. 数据表结构如下:&lt;br&gt;&lt;img src=&quot;/images/2016/02/sms-java-code-3-dbtable.png&quot; class=&quot;center&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://blog.iamlbk.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://blog.iamlbk.com/tags/java/"/>
    
      <category term="发送短信" scheme="http://blog.iamlbk.com/tags/%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>发送短信(二):限制发送频率</title>
    <link href="http://blog.iamlbk.com/20160219/2016-02-19-sms-java-code-2/"/>
    <id>http://blog.iamlbk.com/20160219/2016-02-19-sms-java-code-2/</id>
    <published>2016-02-19T07:07:25.000Z</published>
    <updated>2017-12-02T16:51:02.272Z</updated>
    
    <content type="html"><![CDATA[<p>本篇是发送短信的第二部分, 这里我们介绍一下如何限制向同一个用户(根据手机号和ip)发送短信的频率</p><h2 id="使用session"><a href="#使用session" class="headerlink" title="使用session"></a>使用session</h2><p>如果是web程序, 那么在session中记录上次发送的时间也可以, 但是可以被绕过去. 最简单的, 直接重启浏览器 或者 清除cache等可以标记session的数据, 那么就可以绕过session中的记录. 虽然很多人都不是计算机专业的, 也没学过这些. 但是我们需要注意的是, 之所以限制发送频率, 是为了防止”短信炸弹”, 也就是有人恶意的频繁的请求向某个手机号码发送短信. 所以这个人是有可能懂得这些知识的.</p><a id="more"></a><p>下面我们使用”全局”的数据限制向同一个用户发送频率. 我们先做一些”准备”工作</p><h2 id="定义接口、实体类"><a href="#定义接口、实体类" class="headerlink" title="定义接口、实体类"></a>定义接口、实体类</h2><p>我们需要的实体类如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsEntity</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Integer id;</div><div class="line">    <span class="keyword">private</span> String mobile;</div><div class="line">    <span class="keyword">private</span> String ip;</div><div class="line">    <span class="keyword">private</span> Integer type;</div><div class="line">    <span class="keyword">private</span> Date time;</div><div class="line">    <span class="keyword">private</span> String captcha;</div><div class="line"></div><div class="line">    <span class="comment">// 省略构造方法和getter、setter方法</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>过滤接口如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmsFilter</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 初始化该过滤器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 判断短信是否可以发送.</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> smsEntity 将要发送的短信内容</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 可以发送则返回true, 否则返回false</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(SmsEntity smsEntity)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 销毁该过滤器</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h2 id="主要代码"><a href="#主要代码" class="headerlink" title="主要代码"></a>主要代码</h2><p>限制发送频率, 需要记录某个手机号(IP)及上次发送短信的时间. 很适合<code>Map</code>去完成, 这里我们先使用<code>ConcurrentMap</code>实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FrequencyFilter</span> <span class="keyword">implements</span> <span class="title">SmsFilter</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 发送间隔, 单位: 毫秒</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> sendInterval;</div><div class="line">    <span class="keyword">private</span> ConcurrentMap&lt;String, Long&gt; sendAddressMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="comment">// 省略了部分无用代码</span></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(SmsEntity smsEntity)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(setSendTime(smsEntity.getMobile()) &amp;&amp; setSendTime(smsEntity.getIp()))&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 将发送时间修改为当前时间.</span></div><div class="line"><span class="comment">     * 如果距离上次发送的时间间隔大于&#123;<span class="doctag">@link</span> #sendInterval&#125;则设置发送时间为当前时间. 否则不修改任何内容.</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> id 发送手机号 或 ip</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 如果成功将发送时间修改为当前时间, 则返回true. 否则返回false</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setSendTime</span><span class="params">(String id)</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> currentTime = System.currentTimeMillis();</div><div class="line"></div><div class="line">        Long sendTime = sendAddressMap.putIfAbsent(id, currentTime);</div><div class="line">        <span class="keyword">if</span>(sendTime == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">long</span> nextCanSendTime = sendTime + sendInterval;</div><div class="line">        <span class="keyword">if</span>(currentTime &lt; nextCanSendTime) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> sendAddressMap.replace(id, sendTime, currentTime);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里, 主要的逻辑在<code>setSendTime</code>方法中实现:</p><ul><li>第25-28行: 首先假设用户是第一次发送短信, 那么应该把现在的时间放到<code>sendAddressMap</code>中. 如果<code>putIfAbsent</code>返回<code>null</code>, 那么说明用户确实是第一次发送短信, 而且现在的时间也已经放到了map中, 可以发送.</li><li>第30-33行: 如果用户不是第一次发送短信, 那么就需要判断上次发送短信的时间和现在的间隔是否小于发送时间间隔. 如果小于发送间隔, 那么不能发送.</li><li>第35行: 如果时间间隔足够大, 那么需要尝试着将发送时间设置为当前时间. <ul><li>如果替换成功, 那么可以发送短信. </li><li>如果替换失败, 说明有另外一个线程在本线程执行26-35行之间已经进行了替换, 也就是说在刚才已经发送了一次短信.<ul><li>那么可以再重复执行25-35行, 确保绝对正确.</li><li>也可以直接认为不能发送, 因为虽然理论上”执行26-35行”的时间可能大于”发送间隔”, 但是概率有多大呢? 基本上可以忽略了吧.</li></ul></li></ul></li></ul><p>这段代码算是实现了频率的限制, 但是如果只有”入”而没有”出”那么<code>sendAddressMap</code>占用的内容会越来越大, 直到产生<code>OutOfMemoryError</code>异常. 下面我们再添加代码定时清理过期的数据.</p><h2 id="清理过期数据"><a href="#清理过期数据" class="headerlink" title="清理过期数据"></a>清理过期数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 在上面代码的基础上, 再添加如下代码</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FrequencyFilter</span> <span class="keyword">implements</span> <span class="title">SmsFilter</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">long</span> cleanMapInterval;</div><div class="line">    <span class="keyword">private</span> Timer timer = <span class="keyword">new</span> Timer(<span class="string">"sms_frequency_filter_clear_data_thread"</span>);</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                cleanSendAddressMap();</div><div class="line">            &#125;</div><div class="line">        &#125;, cleanMapInterval, cleanMapInterval);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 将sendAddressMap中的所有过期数据删除</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanSendAddressMap</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> currentTime = System.currentTimeMillis();</div><div class="line">        <span class="keyword">long</span> expireSendTime = currentTime - sendInterval;</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(String key : sendAddressMap.keySet()) &#123;</div><div class="line">            Long sendTime = sendAddressMap.get(key);</div><div class="line">            <span class="keyword">if</span>(sendTime &lt; expireSendTime) &#123;</div><div class="line">                sendAddressMap.remove(key, sendTime);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        timer.cancel();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这段程序不算复杂, 启动一个定时器, 每隔<code>cleanMapInterval</code>毫秒执行一次<code>cleanSendAddressMap</code>方法清理过期数据.</p><p><code>cleanSendAddressMap</code>方法中首先获取当前时间, 根据当前时间获得一个时间值: 所有在这个时间之后发送短信的, 现在不可以再次发送短信. 然后从整个map中删除所有value小于这个时间值的键值对.</p><p>当然, 添加上面的代码后, 最开始的代码又有bug了: 当最后一行<code>sendAddressMap.replace(id, sendTime, currentTime)</code>执行失败时不一定是其他线程进行了替换, 也有可能是清理线程把数据删了. 所以我们需要修改<code>setSendTime</code>方法最后几行:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setSendTime</span><span class="params">(String id)</span> </span>&#123;</div><div class="line">    <span class="comment">// 省略前面的代码</span></div><div class="line">    <span class="keyword">if</span>(sendAddressMap.replace(id, sendTime, currentTime)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sendAddressMap.putIfAbsent(id, currentTime) == <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>这里如果替换成功, 那么直接返回true.</li><li>如果替换不成功. 那么可能是其他线程先替换了(第一种情况); 也可能是被清理线程删除了(第二种情况); 甚至可以能是先被清理线程删除了, 又有其他线程插入了新的时间值(第三种情况). <ul><li>如果是第一种情况 或者 第三种情况, 那么情况和最开始分析的一样, 可以直接认为不能发送. </li><li>如果是第二种情况, 那么应该是可以发送的.</li><li>为了确认是哪种情况, 我们可以执行一次<code>putIfAbsent</code>, 如果成功, 说明是第二种情况, 可以发送; 否则是第一种或者第三种情况, 不能发送.</li></ul></li></ul><p>至此, 限制发送时间的代码就算是完成了. 当然, 这段程序还有一个小bug或者说”特性”: </p><p>假如, IP为”192.168.0.1”的客户请求向手机号”12345678900”发送短信, 然后在<code>sendInterval</code>之内又在IP为”192.168.0.2”的机器上请求向手机号”12345678900”发送短信. 那么短信将不会发出去, 而且手机号”12345678900”的上次发送时间被置为当前时间.</p><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>下面我们提供一个Server层, 展示如何将上一篇以及这一篇中的代码整合到一起:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsService</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> Sms sms;</div><div class="line">    <span class="keyword">private</span> List&lt;SmsFilter&gt; filters;</div><div class="line">    <span class="keyword">private</span> Properties template;</div><div class="line">   </div><div class="line">    <span class="comment">// 省略了部分代码</span></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 发送验证码</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> smsEntity 发送短信的基本数据</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 如果提交成功, 返回0. 否则返回其他值.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sendCaptcha</span><span class="params">(SmsEntity smsEntity)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(SmsFilter filter : filters) &#123;</div><div class="line">            <span class="keyword">if</span>(!filter.filter(smsEntity))&#123;</div><div class="line">                <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(SmsEntity.REGISTER_TYPE.equals(smsEntity.getType())) &#123;</div><div class="line">            sendRegisterSms(smsEntity);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 发送注册验证码</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> smsEntity 发送短信的基本数据</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendRegisterSms</span><span class="params">(SmsEntity smsEntity)</span> </span>&#123;</div><div class="line">        sms.sendMessage(smsEntity.getMobile(),</div><div class="line">                template.getProperty(<span class="string">"register"</span>).replace(<span class="string">"&#123;captcha&#125;"</span>, smsEntity.getCaptcha()));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>之后将<code>FrequencyFilter</code>以及上一篇中的<code>AsyncSmsImpl</code>通过set方法”注入”进去即可.</p><p>最后, 点击<a href="/downloads/code/2016/02/sms2.zip" title="下载源码">这里</a>下载代码.</p><p>发送短信文章:</p><ul><li><a href="/blog/20160219/sms-java-code-1/" title="发送短信--同步/异步发送短信">发送短信–同步/异步发送短信</a>: <a href="http://www.iamlbk.com/blog/20160219/sms-java-code-1/" target="_blank" rel="external">http://www.iamlbk.com/blog/20160219/sms-java-code-1/</a></li><li><a href="/blog/20160219/sms-java-code-2/" title="发送短信--限制发送频率">发送短信–限制发送频率</a>:  <a href="http://www.iamlbk.com/blog/20160219/sms-java-code-2/" target="_blank" rel="external">http://www.iamlbk.com/blog/20160219/sms-java-code-2/</a></li><li><a href="/blog/20160219/sms-java-code-3/" title="发送短信--限制日发送次数">发送短信–限制日发送次数</a>: <a href="http://www.iamlbk.com/blog/20160219/sms-java-code-3/" target="_blank" rel="external">http://www.iamlbk.com/blog/20160219/sms-java-code-3/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇是发送短信的第二部分, 这里我们介绍一下如何限制向同一个用户(根据手机号和ip)发送短信的频率&lt;/p&gt;
&lt;h2 id=&quot;使用session&quot;&gt;&lt;a href=&quot;#使用session&quot; class=&quot;headerlink&quot; title=&quot;使用session&quot;&gt;&lt;/a&gt;使用session&lt;/h2&gt;&lt;p&gt;如果是web程序, 那么在session中记录上次发送的时间也可以, 但是可以被绕过去. 最简单的, 直接重启浏览器 或者 清除cache等可以标记session的数据, 那么就可以绕过session中的记录. 虽然很多人都不是计算机专业的, 也没学过这些. 但是我们需要注意的是, 之所以限制发送频率, 是为了防止”短信炸弹”, 也就是有人恶意的频繁的请求向某个手机号码发送短信. 所以这个人是有可能懂得这些知识的.&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://blog.iamlbk.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://blog.iamlbk.com/tags/java/"/>
    
      <category term="发送短信" scheme="http://blog.iamlbk.com/tags/%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>发送短信(一):同步/异步发送短信</title>
    <link href="http://blog.iamlbk.com/20160219/2016-02-19-sms-java-code-1/"/>
    <id>http://blog.iamlbk.com/20160219/2016-02-19-sms-java-code-1/</id>
    <published>2016-02-19T04:52:11.000Z</published>
    <updated>2017-12-02T16:50:14.642Z</updated>
    
    <content type="html"><![CDATA[<p>本篇本章是发送短信的第一部分, 说一下同步/异步发送短信的代码, 以后几篇我们稍微完善一下功能, 添加发送频率的限制和日发送次数的限制.</p><p>发送短信的方法可能不少, 我们的方法是使用服务商提供的服务. 一般来说, 这些服务都是和语言无关的, 这里我们使用java写示例程序.</p><a id="more"></a><h2 id="发送短信的接口"><a href="#发送短信的接口" class="headerlink" title="发送短信的接口"></a>发送短信的接口</h2><p> 这里我们介绍一些服务商:</p><ul><li>互亿无线: <a href="http://www.ihuyi.com/" target="_blank" rel="external">http://www.ihuyi.com/</a></li><li>容联云通讯: <a href="http://www.yuntongxun.com/" target="_blank" rel="external">http://www.yuntongxun.com/</a></li><li>其他发送短信的接口可以在Api Store上查找: <a href="http://apistore.baidu.com/" target="_blank" rel="external">http://apistore.baidu.com/</a> .比如搜索”短信”: <a href="http://apistore.baidu.com/astore/servicesearch?word=%E7%9F%AD%E4%BF%A1&amp;searchType=null" target="_blank" rel="external">http://apistore.baidu.com/astore/servicesearch?word=%E7%9F%AD%E4%BF%A1&amp;searchType=null</a></li></ul><p>可以都看看, 根据自己的情况选择其中的一款. 这里我使用的是互亿无线, 只是因为我最开始只知道互亿无线, 使用的也是它.</p><h2 id="开发文档"><a href="#开发文档" class="headerlink" title="开发文档"></a>开发文档</h2><p>使用这些服务商提供的服务首先得先看开发文档. 文档在这里下载: <a href="http://h.ihuyi.com/bbs/thread-36-1-1.html" target="_blank" rel="external">http://h.ihuyi.com/bbs/thread-36-1-1.html</a> . 主要的文档如下</p><ul><li>开发说明及常见问题: 简单的开发教程</li><li>接口文档–必须看: 开发文档</li><li>DEMO: 该文件夹下的子文件夹是示例, 以语言命名</li></ul><p>从开发文档中我们可以看到. 可以直接使用http请求也可以使用WebService请求发送短信. 由于DEMO文件夹下的java和jsp文件夹中的代码都是使用http请求发送短信. 所以这里就不再细说了, 我们使用WebService的方式演示发送短信.</p><h2 id="生成客户端代码"><a href="#生成客户端代码" class="headerlink" title="生成客户端代码"></a>生成客户端代码</h2><p>从接口文档中我们知道它的WebService的WSDL的url为: <a href="http://106.ihuyi.cn/webservice/sms.php?WSDL" target="_blank" rel="external">http://106.ihuyi.cn/webservice/sms.php?WSDL</a><br>那么我们可以执行下面的命令生成客户端代码:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wsimport -keep http://106.ihuyi.cn/webservice/sms.php?WSDL</div></pre></td></tr></table></figure><p>其中<code>wsimport</code>是JDK自带的工具, <code>-keep url</code>选项是”保留生成的文件”. 该命令会在当前目录下生成<code>sms.cn.ihuyi._106</code>包, 以及众多的类.<br>接下来开始编写我们自己的代码.</p><h2 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h2><p>为了方便, 这里我们首先定义一个接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sms</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 向mobile发送短信, 内容为message</span></div><div class="line"><span class="comment">     * </span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> mobile  手机号</span></div><div class="line"><span class="comment">     * <span class="doctag">@param</span> message 短信内容</span></div><div class="line"><span class="comment">     * <span class="doctag">@return</span> 成功返回-1, 否则返回其他值</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sendMessage</span><span class="params">(String mobile, String message)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这个接口很简单, 只有一个方法. 这个方法用来发送短信. </p><h2 id="同步发送短信"><a href="#同步发送短信" class="headerlink" title="同步发送短信"></a>同步发送短信</h2><p>接下来我们首先实现一个同步发送短信的类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IhuyiSmsImpl</span> <span class="keyword">implements</span> <span class="title">Sms</span> </span>&#123;</div><div class="line">  </div><div class="line">    <span class="keyword">private</span> String account;</div><div class="line">    <span class="keyword">private</span> String password;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccount</span><span class="params">(String account)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.account = account;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.password = password;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sendMessage</span><span class="params">(String mobile, String message)</span> </span>&#123;</div><div class="line">        cn.ihuyi._106.Sms factory = <span class="keyword">new</span> cn.ihuyi._106.Sms();</div><div class="line">        SmsSoap smsSoap = factory.getSmsSoap();</div><div class="line">        SubmitResult submit = smsSoap.submit(account, password, mobile, message);</div><div class="line">        <span class="keyword">int</span> code = submit.getCode();</div><div class="line">        <span class="keyword">if</span>(code == <span class="number">2</span>)&#123;</div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">        &#125;  </div><div class="line">        System.out.println(<span class="string">"发送短信失败, code:"</span> + code);</div><div class="line">        <span class="keyword">return</span> code;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在第17行, 我们获得远程对象的一个代理对象. 之后就可以通过这个代理对象进行发送短信, 查询账户余额等操作.</p><p>第18行, 使用该代理对象的submit方法提交了短信内容. 该方法的参数信息及返回值含义在接口文档中有详细的说明.</p><p>第19行我们获得了结果的状态码. 根据文档上的说明, 状态码为2说明提交成功. 简单起见, 这里我们只关注提交成功的情况. 需要注意的是, 状态码为2只是说明提交成功. 根据官网上的”3-5秒内响应、100%到达”, 我们可以推测.<br>如果提交成功, 那么基本上3-5秒内,短信就会发送成功, 根据用户的网络情况, 可能稍有延迟用户就可以收到短信.</p><p>使用这段代码发送短信也很简单, 直接<code>new</code>一个对象, 设置好账号和密码就可以发送短信了.</p><h2 id="异步发送短信"><a href="#异步发送短信" class="headerlink" title="异步发送短信"></a>异步发送短信</h2><p>由于发送短信涉及到网络通信, 因此<code>sendMessage</code>方法可能会有一些延迟. 为了改善用户体验, 我们可以使用异步发送短信的方法. 原理很简单: 如果用户请求发送短信, 我们不是直接调用<code>IhuyiSmsImpl</code>的<code>sendMessage</code>方法, 而是将请求保存起来(生产者), 然后告诉用户: 短信发送成功. 之后有若干个消费者取出任务, 调用<code>sendMessage</code>方法发送短信. </p><p>这里, 我使用线程池完成上面的任务:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncSmsImpl</span> <span class="keyword">implements</span> <span class="title">Sms</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> Sms sendSms;</div><div class="line">    <span class="keyword">private</span> ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSendSms</span><span class="params">(Sms sendSms)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.sendSms = sendSms;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sendMessage</span><span class="params">(String mobile, String message)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            executorService.submit(() -&gt; sendSms.sendMessage(mobile, message));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">catch</span>(Exception e) &#123;</div><div class="line">            Sysemt.out.println(<span class="string">"提交任务时发生错误"</span> + e);</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            executorService.shutdown();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">catch</span>(Exception e)&#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>代码很简单, 直接将<code>Sms</code>接口的<code>sendMessage(mobile, message)</code>方法作为一个任务加到线程池的任务队列中. 这样等到有空闲线程时, 就会执行<code>sendSms.sendMessage(mobile, message)</code>发送短信. 这里我们假设只要保存到线程池就可以成功发送短信. 因为发送失败的情况实际上很罕见.</p><p>到这里同步/异步发送短信就算是完成了, 代码可以在<a href="/downloads/code/2016/02/sms1.zip" title="下载源码">这里</a>下载. 接下来的几篇我们看看一些常见的限制的实现, 比如: 一分钟只能发1次, 一天只能发送5次等.</p><p>发送短信文章:</p><ul><li><a href="/blog/20160219/sms-java-code-1/" title="发送短信--同步/异步发送短信">发送短信–同步/异步发送短信</a>: <a href="http://www.iamlbk.com/blog/20160219/sms-java-code-1/" target="_blank" rel="external">http://www.iamlbk.com/blog/20160219/sms-java-code-1/</a></li><li><a href="/blog/20160219/sms-java-code-2/" title="发送短信--限制发送频率">发送短信–限制发送频率</a>:  <a href="http://www.iamlbk.com/blog/20160219/sms-java-code-2/" target="_blank" rel="external">http://www.iamlbk.com/blog/20160219/sms-java-code-2/</a></li><li><a href="/blog/20160219/sms-java-code-3/" title="发送短信--限制日发送次数">发送短信–限制日发送次数</a>: <a href="http://www.iamlbk.com/blog/20160219/sms-java-code-3/" target="_blank" rel="external">http://www.iamlbk.com/blog/20160219/sms-java-code-3/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇本章是发送短信的第一部分, 说一下同步/异步发送短信的代码, 以后几篇我们稍微完善一下功能, 添加发送频率的限制和日发送次数的限制.&lt;/p&gt;
&lt;p&gt;发送短信的方法可能不少, 我们的方法是使用服务商提供的服务. 一般来说, 这些服务都是和语言无关的, 这里我们使用java写示例程序.&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://blog.iamlbk.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://blog.iamlbk.com/tags/java/"/>
    
      <category term="发送短信" scheme="http://blog.iamlbk.com/tags/%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>ssh免密码登录</title>
    <link href="http://blog.iamlbk.com/20160210/2016-02-10-ssh-no-password-login/"/>
    <id>http://blog.iamlbk.com/20160210/2016-02-10-ssh-no-password-login/</id>
    <published>2016-02-10T05:00:57.000Z</published>
    <updated>2017-12-02T16:45:47.406Z</updated>
    
    <content type="html"><![CDATA[<p>由于最近在学习hadoop, 需要ssh免密码登录, 所以学习了一下ssh免密码安装. 在这里记录一下ssh免密码登录的方法和使用场合.</p><h2 id="单机免密码登录"><a href="#单机免密码登录" class="headerlink" title="单机免密码登录"></a>单机免密码登录</h2><p>如果要ssh免密码登录本机, 比如是伪分布模式安装hadoop的话, 就需要ssh免密码登录本机. 那么我们可以使用如下的方式实现免密码登录:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -f ~/.ssh/id_rsa -P <span class="string">''</span>            <span class="comment"># 生成公私钥</span></div><div class="line">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys     <span class="comment"># 共享授权密钥</span></div><div class="line">chmod 600 ~/.ssh/authorized_keys                    <span class="comment"># 修改文件权限</span></div></pre></td></tr></table></figure></p><a id="more"></a><h3 id="命令的解释"><a href="#命令的解释" class="headerlink" title="命令的解释"></a>命令的解释</h3><p>第一行, 使用<code>ssh-keygen</code>生成公私钥.  <code>-t rsa</code>指定生成公私钥的算法为rsa. <code>-f ~/.ssh/id_rsa</code>指定生成的公私钥存放的文件路径, 其中id_rsa存放的是私钥, id_rsa.pub存放的是公钥. <code>-P &#39;&#39;</code>指定密码为空.</p><p>第二行就不再解释了.</p><p>第三行是因为如果authorized_keys文件的权限允许所有者之外的人修改, 那么这个文件中的内容并不起作用. 也就是所有组和其他人都不能拥有写权限, 个人建议权限设置成600. 由于初始时没有authorized_keys文件, 如果authorized_keys文件是由重定向生成的, 那么权限很可能大于644, 所以这里手工修改一下文件权限.</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>在生成公私钥时不指定密码确实不是很安全. 例如, 如果有人登录到你的系统, 就可以免密码登录到所有经过授权的机器(这里是本机). 如果有人拿到了你的私钥, 那么也可以免密码登录到所有经过授权的机器. </p><p>但是由于这里是登录本机, 基本上也就不存在安全问题了: 都已经登录到这台机器了, 再ssh登录这台机器也没有多大的意义; 同样, 如果都拿到私钥了, 那么应该也是登录过这台机子了. 而且还有一点是, 这很可能是在开发环境中, 那么对安全性的要求可能就没有那么高了, 而对便利性的要求可能会较高.</p><h2 id="一台主机到多台主机免密码登录"><a href="#一台主机到多台主机免密码登录" class="headerlink" title="一台主机到多台主机免密码登录"></a>一台主机到多台主机免密码登录</h2><p>这里我们假设我们有四台机器, 主机名分别为: master, slave1, slave2, slave3. 我们的目的是从master免密码登录到slave1-3主机上.</p><h3 id="生成公私钥"><a href="#生成公私钥" class="headerlink" title="生成公私钥"></a>生成公私钥</h3><p>如果还是用上面的方式生成公私钥. 如果有人登录了master主机, 那他就可以免密码登录到所有的slave主机上. 同样如果他拷贝走master上的私钥, 也可以免密码登录到所有的slave主机上. 所以这里建议设置密码. 生成公私钥的命令如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -f ~/.ssh/id_rsa</div><div class="line">``` </div><div class="line">当提示输入密码时, 输入一个密码即可. 下面我们把生成公私钥时输入的密码简称ssh密码.</div><div class="line"><span class="comment">### 共享公钥</span></div><div class="line">这里我们先使用`ssh-copy-id`完成共享公钥. 在master主机上执行如下命令:</div><div class="line">```bash</div><div class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub slave1</div></pre></td></tr></table></figure></p><p>其中<code>-i ~/.ssh/id_rsa.pub</code>指定我们需要共享的公钥文件. slave1为主机名, 也可以写成对应的ip. 执行这条命令时, 需要输入slave1主机上对应账号的密码.<br>之后我们就可以使用ssh密码登录slave1了. 为了免密码登录, 需要为每一个需要免密码登录的主机都执行一次这条命令.</p><h3 id="配置记住密码"><a href="#配置记住密码" class="headerlink" title="配置记住密码"></a>配置记住密码</h3><p>为了记住密码, 我们需要在master主机中的~/.bash_profile中添加如下的命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">eval</span> `ssh-agent`</div><div class="line">ssh-add</div></pre></td></tr></table></figure></p><p>其中第一行是启动ssh-agent服务. 该服务的作用范围为当前shell. 第二行是把专用密钥添加到ssh-agent的高速缓存中. 需要注意的是, 在执行<code>ssh-add</code>时需要输入ssh密码, 所以在开机输入用户名、密码登录后还会提示输入ssh密码. 如果觉得烦人, 可以在以后手动执行<code>ssh-add</code>.</p><p>到这里我们就可以在<strong>这个shell</strong>中免密码登录slave1-3了. 可以使用<code>ssh slave1</code>登录slave1试试, 如果还需要密码, 说明配置有一些问题. 可以在仔细看看上面的步骤.</p><p>如果需要多台主机到多台主机免密码登录, 那么只需要在多台主机间相互共享公钥就行了. 都配置好记住密码就行了.</p><h3 id="安全性-1"><a href="#安全性-1" class="headerlink" title="安全性"></a>安全性</h3><p>我们假设有两个shell: tty1, tty2. 其中tty1上在登录过以后输入了ssh密码. 而tty2上在登录过没有输入ssh密码. 那么在tty2上登录slave1-3时还是需要输入ssh密码的. 所以, 即使有人登录到master主机上, 不知道ssh密码也是不能免密码登录到slave1-3主机的. 同样的, 就算拷贝走私钥, 也没有用. 所以这样是安全的.</p><h2 id="其他共享公钥的方式"><a href="#其他共享公钥的方式" class="headerlink" title="其他共享公钥的方式"></a>其他共享公钥的方式</h2><p>在上面我们是使用<code>ssh-copy-id</code>共享公钥的, 但是当主机很多时, 做好做对这件事将是一个很大的挑战; 当要修改密码, 重新生成公私钥时还得同步所有的公钥… </p><p>为了更加方便, 我们可以这样做:</p><p>在一台机器上创建好用户主目录, 然后生成公私钥, 然后将公钥添加到本机的授权文件中. 比如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</div></pre></td></tr></table></figure></p><p>接着将该用户的主目录设置为nfs共享. 最后其他的主机都不使用自己的主目录, 而是挂载刚才共享的主目录. 那么就可以非常方便的共享公钥了. 具体步骤如下</p><h3 id="创建nfs共享"><a href="#创建nfs共享" class="headerlink" title="创建nfs共享"></a>创建nfs共享</h3><p>在一(多)台机器上生成公私钥. 然后创建nfs共享. 修改<code>/etc/exports</code>文件. 添加如下内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/home/hadoop    192.168.45.0/24(rw,sync)</div></pre></td></tr></table></figure></p><p>个人建议最少在两台机器上生成公私钥, 然后创建nfs共享. 这样万一其中一台由于网络等原因无法挂载时, 可以使用另外一台机器上的数据. 如果有多台机器, 那么需要注意同步数据.</p><h3 id="自动挂载nfs共享"><a href="#自动挂载nfs共享" class="headerlink" title="自动挂载nfs共享"></a>自动挂载nfs共享</h3><p>这里应该是可以直接在<code>/etc/fstab</code>中添加挂载点的. 但是autofs更加适合这里的情况, 所以我们使用autofs.</p><p>首先我们安装autofs. 然后修改<code>/etc/auto.master</code>, 添加如下内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/home/remoteuser    /ect/auto.remoteuser</div></pre></td></tr></table></figure></p><p>其中<code>/home/remoteuser</code>是需要挂载的父级目录, <code>/ect/auto.remoteuser</code>是具体配置文件的位置.<br>接下来, 我们需要编辑<code>/ect/auto.remoteuser</code>(这个文件原本没有, 需要手工创建). 添加如下内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hadoop  -fstype=nfs,rw,soft,intr    nfsserver1,nfsserver2:/home/hadoop</div></pre></td></tr></table></figure></p><p>其中<code>hadoop</code>是挂载点的最后一级目录, <code>/home/remoteuser/hadoop</code>就是最终的挂载点.<br><code>-fstype=nfs,rw,soft,intr</code>是相应的选项.<br><code>nfsserver1,nfsserver2:/home/hadoop</code>中的<code>nfsserver1</code>和<code>nfsserver2</code>是nfs共享的主机名,<code>/home/hadoop</code>是共享的目录.更加灵活的配置方式可以参见<code>man 5 autofs</code></p><p>之后再修改用户的主目录为<code>/home/remoteuser/hadoop</code>. 接下来, 在任意的主机上使用<code>ssh-add</code>添加过密码后, 就可以在该主机该shell上免密码登录所有的主机了.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于最近在学习hadoop, 需要ssh免密码登录, 所以学习了一下ssh免密码安装. 在这里记录一下ssh免密码登录的方法和使用场合.&lt;/p&gt;
&lt;h2 id=&quot;单机免密码登录&quot;&gt;&lt;a href=&quot;#单机免密码登录&quot; class=&quot;headerlink&quot; title=&quot;单机免密码登录&quot;&gt;&lt;/a&gt;单机免密码登录&lt;/h2&gt;&lt;p&gt;如果要ssh免密码登录本机, 比如是伪分布模式安装hadoop的话, 就需要ssh免密码登录本机. 那么我们可以使用如下的方式实现免密码登录:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;ssh-keygen -t rsa -f ~/.ssh/id_rsa -P &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;            &lt;span class=&quot;comment&quot;&gt;# 生成公私钥&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;cat ~/.ssh/id_rsa.pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys     &lt;span class=&quot;comment&quot;&gt;# 共享授权密钥&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;chmod 600 ~/.ssh/authorized_keys                    &lt;span class=&quot;comment&quot;&gt;# 修改文件权限&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://blog.iamlbk.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="ssh" scheme="http://blog.iamlbk.com/tags/ssh/"/>
    
      <category term="linux" scheme="http://blog.iamlbk.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>从N个数中取M个和为指定值的数</title>
    <link href="http://blog.iamlbk.com/20160129/2016-01-29-get-collection-by-sum/"/>
    <id>http://blog.iamlbk.com/20160129/2016-01-29-get-collection-by-sum/</id>
    <published>2016-01-29T03:14:26.000Z</published>
    <updated>2017-12-02T16:44:53.548Z</updated>
    
    <content type="html"><![CDATA[<p>有一个比较常见的问题: 从n个数中取出m个数, 要求这m个数之和是一个固定值. 在n和m比较小时我们直接使用穷举就可以解决这个问题, 但是在n和m比较大时这种方法并不可行. 本文尝试着给出n和m比较大时的解决办法. 当然, 由于本人的水平有限, 无法完全解决这个问题. 所以这种方法有它的局限性, 而且效率也并没有提高太多, 在遇到过大的n和m时仍旧无法使用.</p><p>写这篇博客, 同样是因为csdn上的一个帖子. 这个帖子中要求从125个数中挑选出21个数. 这两个数字对于许多问题来说并不是很大. 但是如果这里采用穷举的方法解决的话, 需要尝试的次数大家可以计算一下…这里我们首先给出穷举法的实现, 之后针对这个题目进行改进, 使程序的运行时间在可以接受的范围内.</p><a id="more"></a><h2 id="穷举法"><a href="#穷举法" class="headerlink" title="穷举法"></a>穷举法</h2><p>要使用穷举法解决这个问题, 就太简单了(虽然运行时间长的不能忍受). 我最先想到的就是使用递归. 废话不多说, 看代码:<br><figure class="highlight java"><figcaption><span>ArraySum.java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">calNextNumber</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> sum, <span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(sum == <span class="number">0</span> &amp;&amp; count ==<span class="number">0</span>)&#123;  <span class="comment">// 符合条件</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 剩余的数字不足 或者 选择的数的和已经超过了总和</span></div><div class="line">    <span class="keyword">if</span> (start + count &gt; array.length || sum &lt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=start; i&lt;array.length; i++) &#123;</div><div class="line">        <span class="keyword">int</span> nextSum = sum - array[i];</div><div class="line">        calResult.offerLast(array[i]);  <span class="comment">// 将可能的结果压入结果栈中</span></div><div class="line">        <span class="keyword">if</span>(calNextNumber(i + <span class="number">1</span>, nextSum, count - <span class="number">1</span>))&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        calResult.pollLast();   <span class="comment">// 不符合要求, 从结果栈中弹出</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这里只给出了关键的代码, 完整代码可以在<a href="/downloads/code/2016/01/getArrayBySum.zip" title="下载源码">这里</a>下载. 帖子中的数据太长了, 也没有贴出来, 各位可以在源码中看到, 或者到《<a href="http://bbs.csdn.net/topics/391897373" title="求解求哪几个数字之和等于一个固定值" target="_blank" rel="external">求解求哪几个数字之和等于一个固定值</a>》里面查看.</p><p>如果使用我自己随便输入的测试数据, 几乎一瞬间就可以计算出来, 而如果用这个程序去计算那个帖子中给的数据, 在我的电脑上跑了两个小时, 还没有计算出来…</p><h2 id="针对帖子中数据的优化"><a href="#针对帖子中数据的优化" class="headerlink" title="针对帖子中数据的优化"></a>针对帖子中数据的优化</h2><p>首先感谢<a href="http://my.csdn.net/kinkon007" title="kinkon007的csdn主页" target="_blank" rel="external">kinkon007</a>的提醒: </p><blockquote><p>可以看到sum的尾数是7，那只有几种情况存在，0+7,1+6,2+5,3+4，先固定匹配好两个尾数，然后再选择其他的数来凑和。</p></blockquote><p>根据这个提示, 我们大致可以想到分而治之的思想. 把数据分成两组:  一组(a组)低三位至少有一个不为0, 一组(b组)低三位都是0. 那么, 我们就可先计算a组, 使计算的结果的低三位和目标的第三位一致. 具体来说就是计算结果为: ***127. 但是个人感觉这样数据量还是很大(没有去数, 纯属感觉). 那么我们就多分几组吧! 一组个位均不为0, 一组个位为0, 十位不为0, 一组个位和十位为0, 百位不为0…<br>然后依次计算.</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>这里我就在上面那个穷举程序的基础上改进. 首先需要修改穷举程序, 使其不是精确到达某个值, 而是低位相等即可.<br>其次, 需要支持”迭代”, 就是说, 调用一次<code>calNextNumber</code>方法获得一组可能的结果, 再调用一次<code>calNextNumber</code>方法, 可以获得下一组可能的结果. 主要代码如下:<br><figure class="highlight java"><figcaption><span>ArraySum1.java </span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">calNextNumber</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> sum, <span class="keyword">int</span> maxCount)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sum &lt;= <span class="number">0</span> || maxCount &lt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    Integer prevEnd = prevStack.pollLast(); <span class="comment">// 取出上一次成功时的状态</span></div><div class="line">    start = prevEnd == <span class="keyword">null</span> ? start : Math.max(start, prevEnd);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; array.length; i++) &#123;</div><div class="line">        <span class="keyword">int</span> nextSum = sum - array[i];</div><div class="line">        calResult.offerLast(array[i]);</div><div class="line">        <span class="comment">// 完全满足 或者 低位一致</span></div><div class="line">        <span class="keyword">if</span> ((nextSum == <span class="number">0</span> &amp;&amp; maxCount - <span class="number">1</span> == <span class="number">0</span>) || nextSum % lowDigit == <span class="number">0</span>) &#123;</div><div class="line">            prevStack.clear(); <span class="comment">// 清除可能残余的上次的状态</span></div><div class="line">            prevStack.offerLast(i + <span class="number">1</span>); <span class="comment">// 保存下次迭代时开始的起点</span></div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (calNextNumber(i + <span class="number">1</span>, nextSum, maxCount - <span class="number">1</span>)) &#123;</div><div class="line">            prevStack.offerLast(i);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        calResult.pollLast();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>接下来, 再通过另外一个类去将数据分组, 调用上面的方法计算. 主要代码如下:<br><figure class="highlight java"><figcaption><span>ArraySum2.java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">splitArray</span><span class="params">(Map&lt;Integer, List&lt;Integer&gt;&gt; map)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</div><div class="line">        <span class="keyword">int</span> digit = <span class="number">0</span>;</div><div class="line">        <span class="keyword">int</span> temp = array[i];</div><div class="line">        <span class="keyword">for</span> (; temp % <span class="number">10</span> == <span class="number">0</span>; temp /= <span class="number">10</span>) &#123;</div><div class="line">            digit++;</div><div class="line">        &#125;</div><div class="line">        List&lt;Integer&gt; tempList = map.get(digit);</div><div class="line">        <span class="keyword">if</span> (tempList == <span class="keyword">null</span>) &#123;</div><div class="line">            tempList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">            map.put(digit, tempList);</div><div class="line">        &#125;</div><div class="line">        tempList.add(array[i]);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createArraySum</span><span class="params">(Map&lt;Integer, List&lt;Integer&gt;&gt; map)</span> </span>&#123;</div><div class="line">    Integer[] keys = map.keySet().toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]);</div><div class="line">    Arrays.sort(keys);</div><div class="line">    <span class="keyword">for</span> (Integer key : keys) &#123;</div><div class="line">        arraySums.add(<span class="keyword">new</span> ArraySum1(map.get(key).toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]), <span class="number">0</span>, <span class="number">0</span>, (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, key + <span class="number">1</span>)));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">calNextArray</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> sum, <span class="keyword">int</span> count)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sum == <span class="number">0</span> &amp;&amp; count == <span class="number">0</span>) &#123; <span class="comment">// 计算完成</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (index &gt;= arraySums.size()) &#123; <span class="comment">// 没有更多分组了</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    ArraySum1 sum1 = arraySums.get(index);</div><div class="line">    sum1.setSum(sum);</div><div class="line">    sum1.setMaxCount(count);</div><div class="line">    <span class="keyword">while</span> (sum1.calNextCollection()) &#123; <span class="comment">// 计算下一个低位符合条件的集合</span></div><div class="line">        <span class="comment">// 递归下一组, 寻找符合条件的集合</span></div><div class="line">        <span class="keyword">if</span> (calNextArray(index + <span class="number">1</span>, sum - sum1.getResultSum(),</div><div class="line">                count - sum1.getResultCount())) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>同样, 这里只有主要代码, 完整代码在<a href="/downloads/code/2016/01/getArrayBySum.zip" title="下载源码">这里</a>下载.</p><h2 id="这种方法的限制"><a href="#这种方法的限制" class="headerlink" title="这种方法的限制"></a>这种方法的限制</h2><p>这种方法并不是可以使用所有的情况. </p><p>首先, 所有的数字需要可以大致均匀的分解成较多的组, 至少不能全部都在一个或者两个组中, 那样的话, 我们进行分组就有没意义了. </p><p>其次, 由于这里可以分得组并不是太多, 所以如果数字过多, 即使可以均匀的分组, 但是如果一个组的数字过多, 同样不适用. 这也是需要改进的地方. </p><p>当然, 还有一个缺点: 这里的代码有点饶. 尤其是<code>ArraySum1</code>中的<code>calNextNumber</code>方法. 或许可以在《<a href="http://blog.csdn.net/min_jie/article/details/3966867" title="从N个数中取出任意个数，求和为指定值的解" target="_blank" rel="external">从N个数中取出任意个数，求和为指定值的解</a>》的基础上进行修改. 由于这篇博客中精巧的设计, 记录上一次的状态非常简单, 可以让程序简单许多. 这里就不提供代码了, 各位可以试试.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有一个比较常见的问题: 从n个数中取出m个数, 要求这m个数之和是一个固定值. 在n和m比较小时我们直接使用穷举就可以解决这个问题, 但是在n和m比较大时这种方法并不可行. 本文尝试着给出n和m比较大时的解决办法. 当然, 由于本人的水平有限, 无法完全解决这个问题. 所以这种方法有它的局限性, 而且效率也并没有提高太多, 在遇到过大的n和m时仍旧无法使用.&lt;/p&gt;
&lt;p&gt;写这篇博客, 同样是因为csdn上的一个帖子. 这个帖子中要求从125个数中挑选出21个数. 这两个数字对于许多问题来说并不是很大. 但是如果这里采用穷举的方法解决的话, 需要尝试的次数大家可以计算一下…这里我们首先给出穷举法的实现, 之后针对这个题目进行改进, 使程序的运行时间在可以接受的范围内.&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://blog.iamlbk.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="分而治之" scheme="http://blog.iamlbk.com/tags/%E5%88%86%E8%80%8C%E6%B2%BB%E4%B9%8B/"/>
    
  </entry>
  
  <entry>
    <title>java中String+String和String+char的区别</title>
    <link href="http://blog.iamlbk.com/20160123/2016-01-23-string-add-string-and-string-add-char/"/>
    <id>http://blog.iamlbk.com/20160123/2016-01-23-string-add-string-and-string-add-char/</id>
    <published>2016-01-23T07:59:34.000Z</published>
    <updated>2017-12-02T16:37:06.822Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们来考虑一个关于java中String的问题:  <code>&quot;abc&quot; + &#39;/&#39;</code>和 <code>&quot;abc&quot; + &quot;/&quot;</code>的区别. 通过这个例子, 我们可以顺便练习一下JDK工具中javap的用法.<br>这个问题是以前在csdn论坛中看到的. 原问题是这样的:</p><blockquote><p>把斜杠/当作字符或字符串有什么区别呢？<br><br>一个是当作基本数据类型char，一个是对象String。具体有什么区别呢？<br><br>当作字符效率会更高吗？<br><br><code>String str = &quot;abc&quot; + &#39;/&#39;;</code><br><br>和<br><br><code>String str = &quot;abc&quot; + &quot;/&quot;;</code><br></p></blockquote><a id="more"></a><h2 id="编译器优化"><a href="#编译器优化" class="headerlink" title="编译器优化"></a>编译器优化</h2><p>首先大家应该知道, 上面那两句效果是一样的, 因为编译器会把上面那两句都优化成下面的样子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String str = <span class="string">"abc/"</span>;</div></pre></td></tr></table></figure></p><p>我们可以通过javap证明这一点. 关于javap, 可以参考《<a href="http://www.csdn.net/article/2014-11-20/2822750-5-JDK-Tools-Every-Java-Developer-Should-Know?reload=1" target="_blank" rel="external">每个Java开发者都应该知道的5个JDK工具</a>》.<br>我们首先创建一个类: <code>StringOne</code>, 在主方法中填入下面的代码(<a href="/downloads/code/2016/01/StringAddString.zip" title="下载源码">下载源码</a>):<br><figure class="highlight java"><figcaption><span>StringOne.java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String str1 = <span class="string">"abc"</span> + <span class="string">'/'</span>;</div><div class="line">String str2 = <span class="string">"abc"</span> + <span class="string">"/"</span>;</div><div class="line">System.out.println(str1 == str2);</div></pre></td></tr></table></figure></p><p>编译并运行, 输出结果为<code>true</code>. 接下来, 该我们的javap登场了, 在命令行中输入下面的命令:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">javap -v -l StringOne.class &gt; StringOne.s</div></pre></td></tr></table></figure></p><p>然后查看生成的StringOne.s文件. 就会发现其中有这么几行(注：javap生成文件中指令的含义可以参考这几篇博客:《<a href="http://www.cnblogs.com/chenqiangjsj/archive/2011/04/02/2003892.html" title="Java栈和局部变量操作（一）" target="_blank" rel="external">Java栈和局部变量操作（一）</a>》,《<a href="http://www.cnblogs.com/chenqiangjsj/archive/2011/04/03/2004231.html" title="Java栈和局部变量操作（二）" target="_blank" rel="external">Java栈和局部变量操作（二）</a>]》,《<a href="http://blog.163.com/hfut_quyouhu/blog/static/7847183520127214559314/" title="java指令集" target="_blank" rel="external">java指令集</a>》):<br><figure class="highlight plain"><figcaption><span>StringOne.s</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&amp;#35;2 = String             #20            // abc/</div><div class="line">...</div><div class="line">&amp;#35;20 = Utf8               abc/</div><div class="line">...</div><div class="line">0: ldc           #2                  // String abc/</div><div class="line">2: astore_1</div><div class="line">3: ldc           #2                  // String abc/</div><div class="line">5: astore_2</div></pre></td></tr></table></figure></p><p>说明<code>str1</code>和<code>str2</code>都引用字符串<code>&quot;abc\&quot;</code>.</p><h2 id="使用javap分析差异"><a href="#使用javap分析差异" class="headerlink" title="使用javap分析差异"></a>使用javap分析差异</h2><p>现在我们换一个问法, 下面的代码中<code>stringAddString</code>和<code>stringAddChar</code>方法有什么区别?<br><figure class="highlight java"><figcaption><span>StringTwo</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">stringAddString</span><span class="params">(String str1, String str2)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> str1 + str2;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">stringAddChar</span><span class="params">(String str, <span class="keyword">char</span> ch)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> str + ch;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这次再使用javap进行反编译, 生成文件的部分内容如下所示<br><figure class="highlight plain"><figcaption><span>StringTwo.s</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public java.lang.String stringAddString(java.lang.String, java.lang.String);</div><div class="line">  descriptor: (Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</div><div class="line">  flags: ACC_PUBLIC</div><div class="line">  Code:</div><div class="line">    stack=2, locals=3, args_size=3</div><div class="line">       0: new           #2                  // class java/lang/StringBuilder</div><div class="line">       3: dup</div><div class="line">       4: invokespecial #3                  // Method java/lang/StringBuilder.&quot;&lt;  init&gt;&quot;:()V</div><div class="line">       7: aload_1</div><div class="line">       8: invokevirtual #4                  // Method java/lang/StringBuilder.  append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</div><div class="line">      11: aload_2</div><div class="line">      12: invokevirtual #4                  // Method java/lang/StringBuilder.  append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</div><div class="line">      15: invokevirtual #5                  // Method java/lang/StringBuilder.  toString:()Ljava/lang/String;</div><div class="line">      18: areturn</div><div class="line"></div><div class="line">public java.lang.String stringAddChar(java.lang.String, char);</div><div class="line">  descriptor: (Ljava/lang/String;C)Ljava/lang/String;</div><div class="line">  flags: ACC_PUBLIC</div><div class="line">  Code:</div><div class="line">    stack=2, locals=3, args_size=3</div><div class="line">       0: new           #2                  // class java/lang/StringBuilder</div><div class="line">       3: dup</div><div class="line">       4: invokespecial #3                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</div><div class="line">       7: aload_1</div><div class="line">       8: invokevirtual #4                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</div><div class="line">      11: iload_2</div><div class="line">      12: invokevirtual #6                  // Method java/lang/StringBuilder.append:(C)Ljava/lang/StringBuilder;</div><div class="line">      15: invokevirtual #5                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</div><div class="line">      18: areturn</div></pre></td></tr></table></figure></p><p>现在, 我们已经可以很清楚的看出这两个方法执行的流程了:</p><p><strong>stringAddString</strong></p><ul><li>创建一个<code>StringBuilder</code>对象</li><li>使用<code>append</code>方法, 依次将两个参数添加到刚才创建的<code>StringBuilder</code>中.</li><li>调用<code>toString</code>方法.</li><li><code>return</code> <code>toString</code>方法的返回值.</li></ul><p><code>stringAddChar</code>的过程和<code>stringAddString</code>一样, 只是在第二次调用<code>append</code>方法时<code>stringAddString</code>的参数是<code>String</code>类型, 而<code>stringAddChar</code>的参数是<code>char</code>类型.</p><h2 id="StringBuilder类的append-char-方法和append-String-方法"><a href="#StringBuilder类的append-char-方法和append-String-方法" class="headerlink" title="StringBuilder类的append(char)方法和append(String)方法"></a>StringBuilder类的append(char)方法和append(String)方法</h2><p>这里，我们直接查看源码就好了（我的是jdk1.8.0_60附带的源码）。<br><strong>注意，虽然文档上显示<code>StringBuilder</code>继承自<code>Object</code>, 但是从源码来看, 它是继承自抽象类<code>AbstractStringBuilder</code>的。而且<code>append</code>方法是由<code>AbstractStringBuilder</code>实现的。</strong></p><figure class="highlight java"><figcaption><span>AbstractStringBuilder.java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</div><div class="line">    ensureCapacityInternal(count + <span class="number">1</span>);    <span class="comment">// 确保数组能够容纳count+1个字符</span></div><div class="line">    value[count++] = c;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> appendNull();</div><div class="line">    <span class="keyword">int</span> len = str.length();</div><div class="line">    ensureCapacityInternal(count + len);</div><div class="line">    str.getChars(<span class="number">0</span>, len, value, count);  <span class="comment">// 拷贝字符串中的字符数组到本对象的字符数组中</span></div><div class="line">    count += len;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>剩下的就不再贴出来了。<code>String.getChars(int, int, char[], int)</code>最终依赖于<code>public static native void arraycopy(Object, int, Object, int, int)</code>。也就是说有可能是C语言写的，在拷贝大型数组时效率应该会比java写的程序好一些。<br>那么，现在说说我的理解：</p><ul><li>从直接内存来说, 由于<code>String</code>中包含char数组, 而数组应该是有长度字段的, 同时<code>String</code>类还有一个<code>int hash</code>属性, 再加上对象本身会占用额外的内存存储其他信息，所以字符串会多占用一些内存. 但是如果字符串非常长, 那么这些内存开销差不多就可以忽略了; 而如果像<code>&quot;/&quot;</code>这种情况, 字符串比较(非常)短,那么就很可能有许多个共享引用来分担这些内存开销, 那么多余的内存开销还是可以忽略的.</li><li>从调用堆栈上, 由于这里<code>String</code>只比<code>char</code>多了一两层函数调用，所以如果不考虑函数调用开销(包括时间和空间), 应该差不多;考虑函数调用开销, <strong><em>应该</em></strong> <strong><code>&quot;abc&quot; + &#39;/&#39;</code></strong>更好一些; 但是当需要连接若干个字符时(感觉这种情况应该更常见吧?), 由于使用<code>char</code>需要循环好多次才能完成连接, 调用的函数次数只会比使用<code>String</code>更多. 同时拷贝也不会比<code>String</code>直接拷贝一个数组更快. 所以这个时候就变成了<strong><code>&quot;abc&quot; + &quot;/&quot;</code></strong>吞吐量更大.</li></ul><p>现在感觉这个问题像是在问: 读写文件时使用系统调用效率高, 还是使用标准函数库中的IO库效率高. 个人感觉, 虽然标准IO库最后还得调用系统调用, 而且这之间会产生一些临时变量, 以及更深层次的调用堆栈, 但是由于IO库的缓冲等机制, 所以IO库的吞吐量会更大, 而系统调用的实时性会好一些. 同样, 虽然<code>String</code>类会多几个字段, 有更深层次的函数堆栈, 但是由于缓存以及更直接的拷贝, 吞吐量应该会更好一些.</p><h2 id="新的问题"><a href="#新的问题" class="headerlink" title="新的问题"></a>新的问题</h2><p>从上面javap的反编译代码来看, 两个<code>String</code>相加, 会变成向<code>StringBuilder</code>中<code>append</code>字符串. 那么理论上, 下面哪段代码的效率好呢?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">String str1 = <span class="string">"abc"</span> + <span class="string">"123"</span>;    <span class="comment">// 1</span></div><div class="line"></div><div class="line">StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();  <span class="comment">// 2</span></div><div class="line">stringBuilder.append(<span class="string">"abc"</span>);</div><div class="line">stringBuilder.append(<span class="string">"123"</span>);</div><div class="line">String str2 = stringBuilder.toString();</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天我们来考虑一个关于java中String的问题:  &lt;code&gt;&amp;quot;abc&amp;quot; + &amp;#39;/&amp;#39;&lt;/code&gt;和 &lt;code&gt;&amp;quot;abc&amp;quot; + &amp;quot;/&amp;quot;&lt;/code&gt;的区别. 通过这个例子, 我们可以顺便练习一下JDK工具中javap的用法.&lt;br&gt;这个问题是以前在csdn论坛中看到的. 原问题是这样的:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;把斜杠/当作字符或字符串有什么区别呢？&lt;br&gt;&lt;br&gt;一个是当作基本数据类型char，一个是对象String。具体有什么区别呢？&lt;br&gt;&lt;br&gt;当作字符效率会更高吗？&lt;br&gt;&lt;br&gt;&lt;code&gt;String str = &amp;quot;abc&amp;quot; + &amp;#39;/&amp;#39;;&lt;/code&gt;&lt;br&gt;&lt;br&gt;和&lt;br&gt;&lt;br&gt;&lt;code&gt;String str = &amp;quot;abc&amp;quot; + &amp;quot;/&amp;quot;;&lt;/code&gt;&lt;br&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://blog.iamlbk.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://blog.iamlbk.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>spring事务管理失效的原因</title>
    <link href="http://blog.iamlbk.com/20160111/2016-01-11-why-spring-transaction-invalid/"/>
    <id>http://blog.iamlbk.com/20160111/2016-01-11-why-spring-transaction-invalid/</id>
    <published>2016-01-11T07:06:23.000Z</published>
    <updated>2017-12-02T16:31:45.518Z</updated>
    
    <content type="html"><![CDATA[<p>个人认为, spring的声明式事务是spring让人感觉用的最爽的功能之一.<br>可是在有些时候, 我们使用spring的声明式事务时却并没有效果.<br>是spring的问题吗? 下面我们先大致说明一下spring声明式事务的原理, 然后再分析在什么情况下, spring的声明式事务会失效.<br><a id="more"></a></p><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>我们知道, spring的声明式事务是基于代理模式的. 那么说事务之前我们还是大致的介绍一下代理模式吧.<br>其实代理模式相当简单, 就是将另一个类包裹在我们的类外面, 在调用我们创建的方法之前,<br>先经过外面的方法, 进行一些处理, 返回之前, 再进行一些操作.<br>比如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span></span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserByName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> userDao.getUserByName(name);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>那么如果配置了事务, 就相当于又创建了一个类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">extends</span> <span class="title">UserService</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> UserService userService;</div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserByName</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        User user = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span>&#123;</div><div class="line">            <span class="comment">// 在这里开启事务</span></div><div class="line">            user = userService.getUserByName(name);</div><div class="line">            <span class="comment">// 在这里提交事务</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">catch</span>(Exception e)&#123;</div><div class="line">            <span class="comment">// 在这里回滚事务</span></div><div class="line">            </div><div class="line">            <span class="comment">// 这块应该需要向外抛异常, 否则我们就无法获取异常信息了. </span></div><div class="line">            <span class="comment">// 至于方法声明没有添加异常声明, 是因为覆写方法, 异常必须和父类声明的异常"兼容". </span></div><div class="line">            <span class="comment">// 这块应该是利用的java虚拟机并不区分普通异常和运行时异常的特点.</span></div><div class="line">            <span class="keyword">throw</span> e;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> user;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>然后我们使用的是<code>UserServiceProxy</code>类, 所以就可以”免费”得到事务的支持:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Autowired</span></div><div class="line"><span class="keyword">private</span> UserService userService;    <span class="comment">// 这里spring注入的实际上是UserServiceProxy的对象</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="comment">// 由于userService是UserServiceProxy的对象, 所以拥有了事务管理的能力</span></div><div class="line">    userService.getUserByName(<span class="string">"aa"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="哪些情况下spring的事务管理会失效"><a href="#哪些情况下spring的事务管理会失效" class="headerlink" title="哪些情况下spring的事务管理会失效"></a>哪些情况下spring的事务管理会失效</h2><h3 id="private方法-final方法-和-static方法不能添加事务"><a href="#private方法-final方法-和-static方法不能添加事务" class="headerlink" title="private方法, final方法 和 static方法不能添加事务"></a><code>private</code>方法, <code>final</code>方法 和 <code>static</code>方法不能添加事务</h3><p>上面的东西并不难. 那么我们可以从上面知道些什么呢?<br>首先, 由于java继承时, 不能重写<code>private</code>, <code>final</code>, <code>static</code>修饰的方法. 所以, 所有的<code>private</code>方法, <code>final</code>方法 和 <code>static</code>方法<br>都无法<strong>直接</strong>添加spring的事务管理功能. 比如下面的代码(完整代码点击[这里][/downloads/code/2016/01/spring-transaction.zip]下载):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 保存两个user对象. 添加了spring事务注解</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="meta">@Transactional</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">saveErrorFinal</span><span class="params">(User user1, User user2)</span> </span>&#123;</div><div class="line">    UserDao userDao = getUserDao(); <span class="comment">// 此处需要使用getUserDao方法. 不能直接使用userDao</span></div><div class="line">    userDao.save(user1);</div><div class="line">    System.out.println(<span class="number">10</span> / <span class="number">0</span>); <span class="comment">// 引发异常</span></div><div class="line">    userDao.save(user2);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 静态方法. 添加了spring事务注解</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="meta">@Transactional</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">saveErrorStatic</span><span class="params">(UserDao userDao, User user1, User user2)</span> </span>&#123;</div><div class="line">    userDao.save(user1);</div><div class="line">    System.out.println(<span class="number">10</span> / <span class="number">0</span>); <span class="comment">// 引发异常</span></div><div class="line">    userDao.save(user2);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 私有方法保存方法. 添加了spring事务注解</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="meta">@Transactional</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveErrorPrivate</span><span class="params">(User user1, User user2)</span> </span>&#123;</div><div class="line">    userDao.save(user1);</div><div class="line">    System.out.println(<span class="number">10</span> / <span class="number">0</span>); <span class="comment">// 引发异常</span></div><div class="line">    userDao.save(user2);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>测试代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 检验user1是否插入成功, 并尝试删除数据. 如果没有插入, 则报错, 并退出.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateInsertSuccess</span><span class="params">()</span> </span>&#123;</div><div class="line">    User user = userService.getUserByName(user1.getName());</div><div class="line">    userService.deleteByName(user1.getName()); <span class="comment">// 删除用户数据</span></div><div class="line">    assertNotEquals(<span class="string">"插入失败!"</span>, -<span class="number">1</span>, user.getId().intValue());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 检验user1是否插入失败. 如果插入成功, 则删除数据, 并报错.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateInsertFail</span><span class="params">()</span> </span>&#123;</div><div class="line">    User user = userService.getUserByName(user1.getName());</div><div class="line">    userService.deleteByName(user1.getName()); <span class="comment">// 删除用户数据</span></div><div class="line">    assertEquals(<span class="string">"插入成功, 事务没有生效!"</span> + user, -<span class="number">1</span>, user.getId().intValue());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSaveErrorFinal</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        userService.saveErrorFinal(user1, user2);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (ArithmeticException e) &#123;&#125;    <span class="comment">// 除零异常, 直接忽略</span></div><div class="line">    validateInsertFail(); <span class="comment">// 我们假设有事务支持, user1添加失败</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSaveErrorStatic</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        UserService.saveErrorStatic(userDao, user1, user2);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">catch</span> (ArithmeticException e) &#123;&#125;</div><div class="line">    validateInsertFail(); <span class="comment">// 我们假设有事务支持, user1添加失败</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>由于<code>saveErrorPrivate</code>方法外面是无法调用的, 就暂时不去讨论了.<br>我们直接看<code>testSaveErrorFinal</code>和<code>testSaveErrorStatic</code>方法的运行结果:<br><br><img src="/images/2016/01/spring-transaction-testSaveErrorFinal.png" alt="testSaveErrorFinal的运行结果"><br><img src="/images/2016/01/spring-transaction-testSaveErrorStatic.png" alt="testSaveErrorStatic的运行结果"><br><br>很明显, 事务并没有生效. 也就是说<code>private</code>方法, <code>final</code>方法 和 <code>static</code>方法都没有事务支持.</p><h3 id="没有通过代理对象调用添加事务的方法"><a href="#没有通过代理对象调用添加事务的方法" class="headerlink" title="没有通过代理对象调用添加事务的方法"></a>没有通过代理对象调用添加事务的方法</h3><p>仔细看看代理模式中的代码, 就会发现不通过代理对象调用方法也会导致spring事务管理失效.<br>绕过代理对象最直接的方法就是自己<code>new</code>一个对象, 虽然这种可能性非常小:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> UserService().save(user);</div></pre></td></tr></table></figure></p><p>当然, 前面也说了, 这种可能性非常小. 那么我们看看第二种情况, 这种情况的可能性也不大:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 保存两个user对象, 中间产生异常. 验证spring的事务是否可以正常工作</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="meta">@Transactional</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveError</span><span class="params">(User user1, User user2)</span> </span>&#123;</div><div class="line">    userDao.save(user1);</div><div class="line">    System.out.println(<span class="number">10</span> / <span class="number">0</span>); <span class="comment">// 引发异常</span></div><div class="line">    userDao.save(user2);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 通过&#123;<span class="doctag">@link</span> #saveError(User, User)&#125;保存数据, 该方法本身并没有添加事务注解. </span></div><div class="line"><span class="comment"> * 而是通过&#123;<span class="doctag">@link</span> #saveError(User, User)&#125;方法使用事务</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveByCallMethod</span><span class="params">(User user1, User user2)</span> </span>&#123;</div><div class="line">    <span class="comment">//saveErrorPrivate(user1, user2);  // 或者调用saveErrorPrivate方法</span></div><div class="line">    saveError(user1, user2);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>由于测试的代码基本上和上面一样, 所以这里我们就不贴测试的代码了. 再说一次, 点击<a href="/downloads/code/2016/01/spring-transaction.zip">这里</a>下载完整代码).<br>实际上, 上面的<code>saveByCallMethod</code>方法还是无法获得spring的事务支持. 因为它的调用堆栈如下图所示(从下向上):<br><br><img src="/images/2016/01/spring-transaction-saveByCallMethod-stack.png" alt="saveByCallMethod的调用堆栈"><br><br>最终结果就是spring的事务管理没有生效. 这是或许你会想了, 那为啥不直接给<code>saveByCallMethod</code>方法添加事务支持呢? 所以我说这种情况的可能性也不大.<br>下面我们再看看事务管理和多线程缠在一起时的情况:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 通过创建一个新的线程, 调用&#123;<span class="doctag">@link</span> #saveError(User, User)&#125;方法来保存用户, 该方法和</span></div><div class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #saveError(User, User)&#125;方法都添加了事务注解</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="meta">@Transactional</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveByThread</span><span class="params">(User user1, User user2)</span> </span>&#123;</div><div class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">//耗时操作</span></div><div class="line">            saveError(user1, user2);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"保存完成"</span>);</div><div class="line">    &#125;).start();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>测试代码请参见我提供的完整代码.<br>这样的代码已经有可能了吧? 那么事务管理会生效吗? 我们再看看调用堆栈就知道了.<br><img src="/images/2016/01/spring-transaction-saveByThread-stack.png" alt="saveByThread的调用堆栈"><br><br>结果和我们想的一样, spring的事务管理并没有生效.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了, 现在我们来回顾一下, 在那些情况下spring的事务管理会失效:</p><ul><li><code>private</code>方法无法添加事务管理.</li><li><code>final</code>方法无法添加事务管理.</li><li><code>static</code>方法无法添加事务管理.</li><li>当绕过代理对象, 直接调用添加事务管理的方法时, 事务管理将无法生效.</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;个人认为, spring的声明式事务是spring让人感觉用的最爽的功能之一.&lt;br&gt;可是在有些时候, 我们使用spring的声明式事务时却并没有效果.&lt;br&gt;是spring的问题吗? 下面我们先大致说明一下spring声明式事务的原理, 然后再分析在什么情况下, spring的声明式事务会失效.&lt;br&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://blog.iamlbk.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://blog.iamlbk.com/tags/java/"/>
    
      <category term="spring" scheme="http://blog.iamlbk.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>java多线程中变量的可见性</title>
    <link href="http://blog.iamlbk.com/20160109/2016-01-09-java-thread-visibility/"/>
    <id>http://blog.iamlbk.com/20160109/2016-01-09-java-thread-visibility/</id>
    <published>2016-01-09T10:52:48.000Z</published>
    <updated>2017-12-02T16:24:56.842Z</updated>
    
    <content type="html"><![CDATA[<p>之所以写这篇博客, 是因为在csdn上看到一个帖子问的就是这个问题. 废话不多说, 我们先看看他的代码(为了减少代码量, 我将创建线程并启动的部分修改为使用方法引用).<br><a id="more"></a></p><h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductAndComsuer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object();  <span class="comment">//锁</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> created = <span class="keyword">false</span>;   <span class="comment">//用以判断是否有产品被消费</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(!created)&#123;  <span class="comment">//说明没有产品了，需要生产</span></div><div class="line">                <span class="keyword">synchronized</span>(lock)&#123;</div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">":生产线程--&gt;"</span> + i++);</div><div class="line">                    created = <span class="keyword">true</span>;</div><div class="line">                    System.out.println(<span class="string">"created--&gt;"</span> + created);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(created)&#123;</div><div class="line">                <span class="keyword">synchronized</span>(lock)&#123;</div><div class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">":消费线程--&gt;"</span> + i);</div><div class="line">                    created = <span class="keyword">false</span>;</div><div class="line">                    System.out.println(<span class="string">"created--&gt;"</span> + created);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> ProductAndComsuer pClass = <span class="keyword">new</span> ProductAndComsuer();</div><div class="line">        <span class="keyword">new</span> Thread(pClass::create).start();</div><div class="line">        <span class="keyword">new</span> Thread(pClass::consume).start();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这是学习多线程非常典型的生产者消费者. 那么这段代码有问题吗?<br>为什么输出几行以后就不动了呢?是死锁了吗?<br>这里我们先复习一下死锁的定义和产生条件.</p><blockquote><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。</p></blockquote><p>而出现死锁必然满足四个条件:</p><ul><li>互斥条件.</li><li>请求和保持条件</li><li>不剥夺条件</li><li>环路等待条件</li></ul><p>再看看这个程序, 第二条就不满足: 一个线程同一时间只会处于保持锁或者请求锁的状态,<br>根本就没有出现请求和保持同时出现的情况. 换(shuo)句(ju)话(ren)说(hua), 这里只有一个锁, 怎么可能发生死锁呢?<br>要证明这一点很简单, 只需要在两个线程的<code>while</code>和<code>if</code>之间加一句打印的语句就知道了. 比如<code>create</code>方法中:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</div><div class="line">    System.out.println(<span class="string">"create方法, created="</span> + created + <span class="string">", 是否满足条件?"</span> + (!created) );</div><div class="line">    <span class="keyword">if</span>(!created) &#123;</div><div class="line">        <span class="keyword">synchronized</span>(lock) &#123;</div><div class="line">            <span class="comment">// 为了方便查看信息, 这里的输出语句注释掉</span></div><div class="line">            <span class="comment">// System.out.println(Thread.currentThread().getName()+":生产线程--&gt;"+i++);</span></div><div class="line">            created = <span class="keyword">true</span>;</div><div class="line">            <span class="comment">// System.out.println("created--&gt;"+created);</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在编译运行程序, 就会发现程序并没有死锁, 那么为什么程序就是不执行同步块中的程序呢? 仔细看一下刚才程序的输出就知道原因了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">create方法, created=true, 是否满足条件?false</div><div class="line">create方法, created=true, 是否满足条件?false</div><div class="line">consume方法, created=false, 是否满足条件?false</div><div class="line">consume方法, created=false, 是否满足条件?false</div></pre></td></tr></table></figure></p><p>我们发现不管是<code>create</code>方法还是<code>consume</code>方法, 都不满足进入<code>if</code>语句的条件. 怎么会这样呢? <code>create</code>方法明明将<code>created</code>赋值为<code>true</code>了.<br>其实, 单独看<code>create</code>方法和<code>consume</code>方法是看不出问题的. 这两个方法很正确. 问题其实是出在多线程中变量的可见性上.<br>在《<a href="http://book.douban.com/subject/2148132/" target="_blank" rel="external">JAVA并发编程实践</a>》(点击查看豆瓣评价)3.1节中说:</p><blockquote><p>在没有同步的情况下, 编译器, 处理器, 运行时安排操作的执行顺序可能完全出人意料. 在没有进行适当同步的多线程程序中, 尝试推断那些”必然”发生在内存中的动作时, 你总是会判断错误.</p></blockquote><p>换句话说, 即使<code>create</code>方法将<code>created</code>赋值为<code>true</code>, 如果没有适当的同步, 那么<code>consume</code>方法中看见的<strong>可能</strong>还是以前的<code>false</code>.<br>同样, <code>create</code>方法看到的也可能是以前的值. 结果, 两个方法就都无法进入自己的<code>if</code>语句块了.</p><p>更糟糕的是, 过期情况并不一定会马上发生, 也不一定会发生在所有的变量上, 当然也不会完全不出现. 所以就有可能被忽略. </p><p>要解决这个问题, 其中一个方法是使用<code>volatile</code>关键字修饰<code>create</code>字段. 那么<code>volatile</code>关键字是干什么的呢? 上面也说了, 过期情况只会发生在没有适当同步的多线程程序中.<br>说道同步, 首先想到的应该就是加锁了吧. 但是加锁的开销太大,<br>而且不合适的锁会导致基本上线性执行的多线程程序(就像这个例子中的程序). 那么有没有其他的方法呢? 那就得靠<code>volatile</code>了.</p><p>《<a href="http://book.douban.com/subject/2148132/" target="_blank" rel="external">JAVA并发编程实践</a>》中是这样说的:</p><blockquote><p>Java语言也提供了其他的选择, 及一种同步的弱形式: volatile变量. 它确保对一个变量的更新会以可预见的方式告知其他的线程.<br><br>…<br><br>所以, 读一个volatile类型的变量时, 总会返回由某一线程所写入的最新值.</p></blockquote><p>也就是说, 我们只需要将<code>create</code>变量的声明前添加<code>volatile</code>关键字即可解决问题:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</div></pre></td></tr></table></figure></p><p>另外, 需要注意《<a href="http://book.douban.com/subject/2148132/" target="_blank" rel="external">JAVA并发编程实践</a>》里面还说到:</p><blockquote><p>当验证正确性必须推断可见性问题时, 应该避免使用volatile变量. 正确使用volatile变量的方式包括: 用于确保他们所引用的对象状态的可见性, 或者用于标示重要的生命事件(比如初始化或者关闭)的方法</p></blockquote><p>也就是说, <code>volatile</code>虽好, 但不能到处随意的使用. 可能是因为<code>volatile</code>容易用错, 所以这个关键字比较低调, 很多地方都没有提过这个关键字. 简单的说, 因为<code>volatile</code>不能提供原子性, 所以使用<code>volatile</code>的变量的所有读取/修改必须是原子修改, 比如<code>x++</code>就不是, 因为是先读取又写入. 这里我们就不深入说了, 要了解更多信息可以翻翻《<a href="http://book.douban.com/subject/2148132/" target="_blank" rel="external">JAVA并发编程实践</a>》或者看看这篇”文档”《<a href="http://www.ibm.com/developerworks/cn/java/j-jtp06197.html" target="_blank" rel="external">Java 理论与实践: 正确使用 Volatile 变量</a>》.</p><p>最后, 我们再说说如何使用同步块解决这个问题. 其实很简单, 只需要将同步块和<code>if</code>语句对调即可:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">   <span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object();  <span class="comment">//锁</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> created = <span class="keyword">false</span>;   <span class="comment">//用以判断是否有产品被消费</span></div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">()</span></span>&#123;</div><div class="line">       <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">           <span class="keyword">synchronized</span>(lock)&#123; <span class="comment">// 先加锁, 再判断</span></div><div class="line">               <span class="keyword">if</span>(!created)&#123;</div><div class="line">                   ...</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span></span>&#123;</div><div class="line">       <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</div><div class="line">           <span class="keyword">synchronized</span>(lock)&#123;</div><div class="line">               <span class="keyword">if</span>(created)&#123;</div><div class="line">                   ...</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之所以写这篇博客, 是因为在csdn上看到一个帖子问的就是这个问题. 废话不多说, 我们先看看他的代码(为了减少代码量, 我将创建线程并启动的部分修改为使用方法引用).&lt;br&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://blog.iamlbk.com/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="java" scheme="http://blog.iamlbk.com/tags/java/"/>
    
      <category term="多线程" scheme="http://blog.iamlbk.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>为octopress添加标签</title>
    <link href="http://blog.iamlbk.com/20160108/2016-01-08-octopress-add-tag-cloud/"/>
    <id>http://blog.iamlbk.com/20160108/2016-01-08-octopress-add-tag-cloud/</id>
    <published>2016-01-08T05:33:03.000Z</published>
    <updated>2017-12-02T16:23:20.655Z</updated>
    
    <content type="html"><![CDATA[<p>octopress默认只有分类,没有标签.这让习惯使用三四个分类, 无数个标签管理博客的我很不习惯.<br>于是在网上找为octopress添加标签的方式. 这篇博客的部分内容参考:《<a href="http://codemacro.com/2012/07/18/add-tag-to-octopress" target="_blank" rel="external">为octopress添加tag cloud</a>》.<br><a id="more"></a></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>首先, 下载需要的插件: <a href="https://github.com/robbyedwards/octopress-tag-pages" target="_blank" rel="external">octopress-tag-pages</a>和<a href="https://github.com/robbyedwards/octopress-tag-cloud" target="_blank" rel="external">octopress-tag-cloud</a>. 使用git clone或者直接下载压缩包都行.</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装其实很简单, 只需要将下面几个文件复制到octopress中相应的目录中即可:</p><p>octopress-tag-pages中的</p><ul><li>plugins/tag_generator.rb</li><li>source/_layouts/tag_index.html</li><li>source/_includes/custom/tag_feed.xml</li></ul><p>octopress-tag-cloud中的</p><ul><li>plugins/tag_cloud.rb</li><li>source/_includes/custom/asides/tags.html(如果需要汉化, 直接修改这里面的内容即可)</li></ul><p>例如, 把octopress-tag-pages中的plugins/tag_generator.rb复制到octopress安装目录下的plugins文件夹中.</p><p>最后, 修改_config.xml中的default_asides, 将custom/asides/tags.html添加进去:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">default_asides:</span> <span class="string">[custom/asides/category_list.html,</span> <span class="string">custom/asides/tags.html,</span> <span class="string">...]</span></div></pre></td></tr></table></figure></p><p>至此, 已经安装完毕. 可能已经有读者迫不及待的想要看看效果了. 可是执行<code>rake generate</code>却发生了错误(这个错误并不是所有人都会遇到)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Liquid Exception: comparison of Array with Array failed in _layouts/page.html</div></pre></td></tr></table></figure></p><h2 id="排错"><a href="#排错" class="headerlink" title="排错"></a>排错</h2><h3 id="第一个错误-comparison-of-Array-with-Array-failed-in-layouts-page-html"><a href="#第一个错误-comparison-of-Array-with-Array-failed-in-layouts-page-html" class="headerlink" title="第一个错误: comparison of Array with Array failed in _layouts/page.html"></a>第一个错误: comparison of Array with Array failed in _layouts/page.html</h3><p>我们就是按照文档写的. 那么到底哪里错了? 我们看看刚才安装的两个插件的源码就知道了(没学过ruby没关系, 这两个插件的注释写的很完整, 我也没学过ruby, 但是也大致看得懂这个程序). 在tag_cloud.rb中第74行是这么写的:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> @limit &gt; <span class="number">0</span> <span class="keyword">and</span> @sort != <span class="string">'rand'</span></div><div class="line">    <span class="comment"># sort the tag pairs by frequency in descending order</span></div><div class="line">    weighted.sort! &#123; <span class="params">|a,b|</span> b[<span class="number">1</span>] &lt;=&gt; a[<span class="number">1</span>] &#125;</div><div class="line"></div><div class="line">    <span class="comment"># then slice off the top <span class="doctag">@limit</span> tag pairs</span></div><div class="line">    weighted = weighted[<span class="number">0</span>,@limit]</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p><p><code>weighted = weighted[0,@limit]</code>应该就是取指定数目的标签. 如果你的标签数量少于<code>@limit</code>, 那么就会报错. 所以我们修改第74行为:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> @limit &gt; <span class="number">0</span> <span class="keyword">and</span> @sort != <span class="string">'rand'</span> <span class="keyword">and</span> @limit &lt; weighted.length</div></pre></td></tr></table></figure></p><p>同样的, 将第95行修改为:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> @limit &gt; <span class="number">0</span> <span class="keyword">and</span> @limit &lt; weighted.length</div></pre></td></tr></table></figure></p><p>这时再执行<code>rake generate</code>就不会报错了. 但是又出现了几条警告:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Build Warning: Layout &apos;nil&apos; requested in tags/github page/atom.xml does not exist.exist.</div></pre></td></tr></table></figure></p><h3 id="又一个警告-Layout-‘nil’-requested-in-tags-标签名-atom-xml-does-not-exist"><a href="#又一个警告-Layout-‘nil’-requested-in-tags-标签名-atom-xml-does-not-exist" class="headerlink" title="又一个警告:Layout ‘nil’ requested in tags/标签名/atom.xml does not exist."></a>又一个警告:Layout ‘nil’ requested in tags/标签名/atom.xml does not exist.</h3><p>这个警告让人很摸不着头脑, 而且并不影响使用, 但是让人感觉很不爽, 所以继续在源码中查找问题.<br>然后无意间发现tag_generator.rb中的代码结构和category_generator.rb中的代码结构一模一样.<br>而category_generator.rb是用来生成类别信息的. 那么为什么生成类别信息时没有警告, 而生成标签信息时就会有警告呢?<br>仔细对比之后也没有发现什么问题. 后来发现tag_generator.rb中加载了我们安装时复制过来的tag_feed.xml文件. tag_feed.xml里面有这么一句话:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">layout:</span> <span class="string">nil</span></div></pre></td></tr></table></figure></p><p>而category_generator.rb加载了category_feed.xml文件. category_feed.xml里面对应的位置是:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">layout:</span> <span class="literal">null</span></div></pre></td></tr></table></figure></p><p>是不是这里呢? 改过来试试吧. 好吧, 就是这里.</p><h3 id="基本不会遇见的问题"><a href="#基本不会遇见的问题" class="headerlink" title="基本不会遇见的问题"></a>基本不会遇见的问题</h3><p>到现在侧边栏的标签已经能正常使用了. 但是, 如果你跟我一样, 刚刚开始使用octopress, 只有一两篇博客, 而且所有的标签的博客数量都一样, 那么就会发现左侧的标签的源码是这样:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">style</span>=<span class="string">"font-size: NaN%"</span> <span class="attr">href</span>=<span class="string">"/tags/github-page/"</span>&gt;</span>github page<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure></p><p>这并不影响使用, 而且相当的罕见. 所以我们直接说解决方案吧.<br>将tag_cloud.rb第69行改为:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> max == min</div><div class="line">  weight = (<span class="number">100</span> - size_min) / (size_max - size_min)</div><div class="line"><span class="keyword">else</span></div><div class="line">  weight = (Math.log(count) - Math.log(min))/(Math.log(max) - Math.log(min))</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure></p><p>这时就可以正常使用了.</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="中文化"><a href="#中文化" class="headerlink" title="中文化"></a>中文化</h3><p>如果用户点击边栏上的标签, 会跳转到标签页. 而标签页的默认标题为:<code>Tag: 标签名</code>.<br>如果想将其中的”Tag:”换成中文的, 可以在_config.yml中添加下面的内容:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">tag_title_prefix:</span> <span class="string">"标签--"</span></div></pre></td></tr></table></figure></p><p>重新生成一下, 标题就会变成<code>标签--标签名</code></p><h3 id="配置边栏中标签的数量"><a href="#配置边栏中标签的数量" class="headerlink" title="配置边栏中标签的数量"></a>配置边栏中标签的数量</h3><p>[octopress-tag-cloud][]的文档上说可以使用limit限制显示标签的数量(刚开始遇到的错误也是因为配置的limit太大了造成的). 直接修改source/_includes/custom/asides/tags.html中的limit后面的数字即可:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;% tag_cloud font-size: 60-165%, limit: 15 %&#125;</div></pre></td></tr></table></figure></p><h3 id="在文章列表中显示标签"><a href="#在文章列表中显示标签" class="headerlink" title="在文章列表中显示标签"></a>在文章列表中显示标签</h3><p>效果如图:<br><img src="/images/2016/01/archives-list-tags.png" class="center"><br>将octopress-tag-pages插件中的source/_includes/archive_post.html复制到octopress中的source/_includes/目录下, 该文件本来已经有了, 直接覆盖就可以.</p><p>或者如果你已经修改过octopress中的source/_includes/archive_post.html文件了, 那么可以参考插件中的文件, 直接将<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&amp;#123;% if tag != &apos;0&apos; %&#125;</div><div class="line">  &lt;span class=&quot;tags&quot;&gt;tagged with &amp;#123;&#123; post.tags | tag_links &#125;&#125;&lt;/span&gt;</div><div class="line">&amp;#123;% endif %&#125;</div></pre></td></tr></table></figure></p><p>复制到octopress下的文件中的特定位置即可.</p><h3 id="在博客下面或者上面显示标签"><a href="#在博客下面或者上面显示标签" class="headerlink" title="在博客下面或者上面显示标签"></a>在博客下面或者上面显示标签</h3><p>还是先上个图:<br><img src="/images/2016/01/archives-tags.png" class="center"><br>参考octopress-tag-pages插件中的source/_layouts目录中的post.html, 修改octopress下的post.html, 比如我的post.html中相应的部分是这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;p class=&quot;meta&quot;&gt;</div><div class="line">    &amp;#123;% include post/categories.html %&#125;</div><div class="line">    &amp;#123;% include post/tags.html %&#125;</div><div class="line">    &lt;br/&gt;</div><div class="line">    &amp;#123;% include post/author.html %&#125;</div><div class="line">    &amp;#123;% include post/date.html %&#125;</div><div class="line">    &amp;#123;&#123; time &#125;&#125;</div><div class="line">    &amp;#123;% if updated %&#125; </div><div class="line">        &amp;#123;&#123; updated &#125;&#125;</div><div class="line">    &amp;#123;% endif %&#125;</div><div class="line">&lt;/p&gt;</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;octopress默认只有分类,没有标签.这让习惯使用三四个分类, 无数个标签管理博客的我很不习惯.&lt;br&gt;于是在网上找为octopress添加标签的方式. 这篇博客的部分内容参考:《&lt;a href=&quot;http://codemacro.com/2012/07/18/add-tag-to-octopress&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;为octopress添加tag cloud&lt;/a&gt;》.&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://blog.iamlbk.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="octopress" scheme="http://blog.iamlbk.com/tags/octopress/"/>
    
      <category term="github page" scheme="http://blog.iamlbk.com/tags/github-page/"/>
    
  </entry>
  
  <entry>
    <title>使用Octopress搭建博客时遇到invalid byte sequence in GB2313的解决办法</title>
    <link href="http://blog.iamlbk.com/20160107/2016-01-07-invalid-byte-sequence-in-gb2313/"/>
    <id>http://blog.iamlbk.com/20160107/2016-01-07-invalid-byte-sequence-in-gb2313/</id>
    <published>2016-01-07T01:33:03.000Z</published>
    <updated>2017-12-02T16:20:44.706Z</updated>
    
    <content type="html"><![CDATA[<p>我是参考《<a href="http://yidao620c.github.io/2015/03/18/octopress-blog.html" target="_blank" rel="external">windows7上面使用Octopress搭建GitHub博客</a>》和《<a href="http://www.jianshu.com/p/1a117ef0e534" target="_blank" rel="external">Octopress安装和配置</a>》搭建自己的Github博客的.基本上是大事没有,小事不断.其中出现次数最多的是编码问题:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Liquid Exception: invalid byte sequence in GB2312</div></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jekyll 2.5.3 | Error:  invalid byte sequence in GB2312</div></pre></td></tr></table></figure></p><a id="more"></a><p>我的错误信息在这个时候出现的: 按《<a href="http://yidao620c.github.io/2015/03/18/octopress-blog.html" target="_blank" rel="external">windows7上面使用Octopress搭建GitHub博客</a>》上的步骤, 到中文化的时候, 修改source/_includes/custom/navigation.html和source/_includes/custom/footer.html时都没有问题, 但是修改source/_includes/asides/recent_posts.html之后就会出现该错误信息.</p><p>上网查了N多解决办法,无奈大多数都是针对jekyll 1.4.x版本的, 而我的是2.5.3, 基本没有用, 最后在《<a href="http://blog.csdn.net/jiedushi/article/details/8529110" target="_blank" rel="external">ruby中in `split’: invalid byte sequence in UTF-8 (ArgumentError)解决方法</a>》上看到了这样一段话:</p><blockquote><p>将arr=arr = url.split(“&amp;”)修改为<br><br>arr = url.force_encoding(“gb2312”).split(“&amp;”)  即可</p></blockquote><p>就抱着最后一次的心态试了一下, 使用<code>rake generate --trace</code>生成页面, 后面的<code>--trace</code>是用来打印错误的堆栈信息的. 最后发现错误是在”ruby安装目录\lib\ruby\gems\1.9.1\gems\liquid-2.6.3\lib\liquid\template.rb”的第147行发生的. 然后按照《<a href="http://blog.csdn.net/jiedushi/article/details/8529110" target="_blank" rel="external">ruby中in `split’: invalid byte sequence in UTF-8 (ArgumentError)解决方法</a>》上面的说法, 将<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tokens = source.split(TemplateParser)</div></pre></td></tr></table></figure></p><p>改成<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tokens = source.force_encoding(<span class="string">"gb2313"</span>).split(TemplateParser)</div></pre></td></tr></table></figure></p><p>错误依旧…</p><p>然后猛然间发现人家提示的是”invalid byte sequence in utf-8”, 而我的提醒的是”invalid byte sequence in GB2313”, 所以改成<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tokens = source.force_encoding(<span class="string">"utf-8"</span>).split(TemplateParser)</div></pre></td></tr></table></figure></p><p>问题成功解决.我没学过ruby, 但是看这个路径修改的应该是ruby系统或者是ruby某个库的系统文件代码, 这并不是一个好习惯. 但也只能这样做了.</p><p>ps: 今天写这篇博客时, 为了还原”现场”, 又将那行改了回去:<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tokens = source.split(TemplateParser)</div></pre></td></tr></table></figure></p><p>然后惊奇的发现, 又没有问题了…这是个未解之谜.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我是参考《&lt;a href=&quot;http://yidao620c.github.io/2015/03/18/octopress-blog.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;windows7上面使用Octopress搭建GitHub博客&lt;/a&gt;》和《&lt;a href=&quot;http://www.jianshu.com/p/1a117ef0e534&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Octopress安装和配置&lt;/a&gt;》搭建自己的Github博客的.基本上是大事没有,小事不断.其中出现次数最多的是编码问题:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;Liquid Exception: invalid byte sequence in GB2312&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;或者&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;jekyll 2.5.3 | Error:  invalid byte sequence in GB2312&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://blog.iamlbk.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="octopress" scheme="http://blog.iamlbk.com/tags/octopress/"/>
    
      <category term="github page" scheme="http://blog.iamlbk.com/tags/github-page/"/>
    
  </entry>
  
</feed>
